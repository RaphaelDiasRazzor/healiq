==============================================================================
Config.lua
==============================================================================
      -- HealIQ Config.lua
      -- Handles slash commands and user options

   13 local addonName, HealIQ = ...

   13 HealIQ.Config = {}
   13 local Config = HealIQ.Config



      -- Command handlers
   13 local commands = {}

   13 function Config:Initialize()
****0     HealIQ:SafeCall(function()
****0         self:RegisterSlashCommands()
****0         HealIQ:Print("Config initialized")
          end)
      end

   13 function Config:RegisterSlashCommands()
****0     SLASH_HEALIQ1 = "/healiq"
****0     SLASH_HEALIQ2 = "/hiq"
          
          SlashCmdList["HEALIQ"] = function(msg)
****0         Config:HandleSlashCommand(msg)
          end
      end

   13 function Config:HandleSlashCommand(msg)
****0     HealIQ:SafeCall(function()
****0         local args = {}
****0         for word in msg:gmatch("%S+") do
****0             table.insert(args, word:lower())
              end
              
****0         local command = args[1] or "help"
              
****0         if commands[command] then
****0             commands[command](unpack(args, 2))
              else
****0             self:ShowHelp()
              end
          end)
      end

      -- Command implementations
      commands.help = function()
    3     print("|cFF00FF00HealIQ v" .. HealIQ.version .. " Commands:|r")
    3     print("|cFFFFFF00/healiq|r - Show this help")
    3     print("|cFFFFFF00/healiq version|r - Show version information")
    3     print("|cFFFFFF00/healiq config|r - Open options window")
    3     print("|cFFFFFF00/healiq toggle|r - Toggle addon on/off")
    3     print("|cFFFFFF00/healiq enable|r - Enable addon")
    3     print("|cFFFFFF00/healiq disable|r - Disable addon")
    3     print("|cFFFFFF00/healiq ui|r - Show UI commands")
    3     print("|cFFFFFF00/healiq rules|r - Show rule commands")
    3     print("|cFFFFFF00/healiq strategy|r - Show strategy commands")
    3     print("|cFFFFFF00/healiq test|r - Test suggestion display")
    3     print("|cFFFFFF00/healiq test queue|r - Test queue display")
    3     print("|cFFFFFF00/healiq test ui|r - Test UI with sample queue")
    3     print("|cFFFFFF00/healiq test targeting|r - Test targeting suggestions")
    3     print("|cFFFFFF00/healiq debug|r - Toggle debug mode")
    3     print("|cFFFFFF00/healiq dump|r - Generate diagnostic dump")
    3     print("|cFFFFFF00/healiq reset|r - Reset all settings")
    3     print("|cFFFFFF00/healiq reload|r - Reload addon configuration")
    3     print("|cFFFFFF00/healiq status|r - Show current status")
      end

      commands.version = function()
    3     print("|cFF00FF00HealIQ|r Version " .. HealIQ.version)
    3     print("  Interface: 110107 (The War Within)")
    3     print("  Author: djdefi")
    3     print("  Description: Smart healing spell suggestion addon for Restoration Druids")
    3     print("  GitHub: https://github.com/djdefi/healiq")
      end

      commands.toggle = function()
    5     if not HealIQ.db then
****0         print("|cFFFF0000HealIQ|r Database not yet initialized")
****0         return
          end
          
    5     HealIQ.db.enabled = not HealIQ.db.enabled
    5     local status = HealIQ.db.enabled and "enabled" or "disabled"
    5     print("|cFF00FF00HealIQ|r " .. status)
          
    5     if HealIQ.UI then
    5         HealIQ.UI:SetEnabled(HealIQ.db.enabled)
          end
      end

      commands.config = function()
    3     if HealIQ.UI then
    3         HealIQ.UI:ToggleOptionsFrame()
          end
      end

      commands.enable = function()
    5     if not HealIQ.db then
****0         print("|cFFFF0000HealIQ|r Database not yet initialized")
****0         return
          end
          
    5     HealIQ.db.enabled = true
    5     print("|cFF00FF00HealIQ|r enabled")
          
    5     if HealIQ.UI then
    5         HealIQ.UI:SetEnabled(true)
          end
      end

      commands.disable = function()
    5     if not HealIQ.db then
****0         print("|cFFFF0000HealIQ|r Database not yet initialized")
****0         return
          end
          
    5     HealIQ.db.enabled = false
    5     print("|cFF00FF00HealIQ|r disabled")
          
    5     if HealIQ.UI then
    5         HealIQ.UI:SetEnabled(false)
          end
      end

      commands.ui = function(subcommand, ...)
   19     if not HealIQ.db or not HealIQ.db.ui then
****0         print("|cFFFF0000HealIQ|r Database not yet initialized")
****0         return
          end
          
   19     if subcommand == "lock" then
    5         HealIQ.db.ui.locked = true
    5         print("|cFF00FF00HealIQ|r UI locked")
   14     elseif subcommand == "unlock" then
    5         HealIQ.db.ui.locked = false
    5         print("|cFF00FF00HealIQ|r UI unlocked")
    9     elseif subcommand == "scale" then
****0         local scale = tonumber((...))
****0         if scale and HealIQ.UI then
****0             HealIQ.UI:SetScale(scale)
              else
****0             print("|cFF00FF00HealIQ|r Usage: /healiq ui scale <0.5-2.0>")
              end
    9     elseif subcommand == "reset" then
****0         if HealIQ.UI then
****0             HealIQ.UI:ResetPosition()
              end
    9     elseif subcommand == "name" then
****0         local show = ... == "show"
****0         if HealIQ.UI then
****0             HealIQ.UI:SetShowSpellName(show)
              end
****0         print("|cFF00FF00HealIQ|r Spell name display " .. (show and "enabled" or "disabled"))
    9     elseif subcommand == "cooldown" then
****0         local show = ... == "show"
****0         if HealIQ.UI then
****0             HealIQ.UI:SetShowCooldown(show)
              end
****0         print("|cFF00FF00HealIQ|r Cooldown display " .. (show and "enabled" or "disabled"))
    9     elseif subcommand == "queue" then
****0         local show = ... == "show"
****0         HealIQ.db.ui.showQueue = show
****0         if HealIQ.UI then
****0             HealIQ.UI:RecreateFrames()
              end
****0         print("|cFF00FF00HealIQ|r Queue display " .. (show and "enabled" or "disabled"))
    9     elseif subcommand == "queuesize" then
    5         local size = tonumber((...))
    5         if size and size >= 2 and size <= 5 then
    5             HealIQ.db.ui.queueSize = size
    5             if HealIQ.UI then
    5                 HealIQ.UI:RecreateFrames()
                  end
****0             print("|cFF00FF00HealIQ|r Queue size set to " .. size)
              else
****0             print("|cFF00FF00HealIQ|r Usage: /healiq ui queuesize <2-5>")
              end
    4     elseif subcommand == "layout" then
    4         local layout = ... or "horizontal"
    4         if layout == "horizontal" or layout == "vertical" then
    4             HealIQ.db.ui.queueLayout = layout
    4             if HealIQ.UI then
    4                 HealIQ.UI:RecreateFrames()
                  end
****0             print("|cFF00FF00HealIQ|r Queue layout set to " .. layout)
              else
****0             print("|cFF00FF00HealIQ|r Usage: /healiq ui layout <horizontal|vertical>")
              end
****0     elseif subcommand == "targeting" then
****0         local show = ... == "show"
****0         HealIQ.db.ui.showTargeting = show
****0         if HealIQ.Engine then
****0             HealIQ.Engine:ForceUpdate()
              end
****0         print("|cFF00FF00HealIQ|r Targeting suggestions " .. (show and "enabled" or "disabled"))
****0     elseif subcommand == "targetingicon" then
****0         local show = ... == "show"
****0         HealIQ.db.ui.showTargetingIcon = show
****0         if HealIQ.Engine then
****0             HealIQ.Engine:ForceUpdate()
              end
****0         print("|cFF00FF00HealIQ|r Targeting icons " .. (show and "enabled" or "disabled"))
          else
****0         print("|cFF00FF00HealIQ UI Commands:|r")
****0         print("|cFFFFFF00/healiq ui lock|r - Lock UI position")
****0         print("|cFFFFFF00/healiq ui unlock|r - Unlock UI position")
****0         print("|cFFFFFF00/healiq ui scale <number>|r - Set UI scale (0.5-2.0)")
****0         print("|cFFFFFF00/healiq ui reset|r - Reset UI position")
****0         print("|cFFFFFF00/healiq ui name show/hide|r - Show/hide spell names")
****0         print("|cFFFFFF00/healiq ui cooldown show/hide|r - Show/hide cooldowns")
****0         print("|cFFFFFF00/healiq ui queue show/hide|r - Show/hide queue display")
****0         print("|cFFFFFF00/healiq ui queuesize <2-5>|r - Set queue size")
****0         print("|cFFFFFF00/healiq ui layout horizontal/vertical|r - Set queue layout")
****0         print("|cFFFFFF00/healiq ui targeting show/hide|r - Show/hide targeting suggestions")
****0         print("|cFFFFFF00/healiq ui targetingicon show/hide|r - Show/hide targeting icons")
          end
      end

      commands.rules = function(subcommand, ...)
****0     if not HealIQ.db or not HealIQ.db.rules then
****0         print("|cFFFF0000HealIQ|r Database not yet initialized")
****0         return
          end
          
****0     if subcommand == "list" then
****0         print("|cFF00FF00HealIQ Rules:|r")
****0         for rule, enabled in pairs(HealIQ.db.rules) do
****0             local status = enabled and "|cFF00FF00enabled|r" or "|cFFFF0000disabled|r"
****0             print("  " .. rule .. ": " .. status)
              end
****0     elseif subcommand == "enable" then
****0         local rule = ...
****0         if rule and HealIQ.db.rules[rule] ~= nil then
****0             HealIQ.db.rules[rule] = true
****0             print("|cFF00FF00HealIQ|r Rule '" .. rule .. "' enabled")
              else
****0             print("|cFF00FF00HealIQ|r Unknown rule: " .. tostring(rule))
              end
****0     elseif subcommand == "disable" then
****0         local rule = ...
****0         if rule and HealIQ.db.rules[rule] ~= nil then
****0             HealIQ.db.rules[rule] = false
****0             print("|cFF00FF00HealIQ|r Rule '" .. rule .. "' disabled")
              else
****0             print("|cFF00FF00HealIQ|r Unknown rule: " .. tostring(rule))
              end
          else
****0         print("|cFF00FF00HealIQ Rule Commands:|r")
****0         print("|cFFFFFF00/healiq rules list|r - List all rules and their status")
****0         print("|cFFFFFF00/healiq rules enable <rule>|r - Enable a specific rule")
****0         print("|cFFFFFF00/healiq rules disable <rule>|r - Disable a specific rule")
****0         print("|cFFFFFF00Rules:|r wildGrowth, clearcasting, lifebloom, swiftmend, rejuvenation,")
****0         print("  ironbark, efflorescence, tranquility, incarnationTree, naturesSwiftness,")
****0         print("  barkskin, flourish, groveGuardians, wrath")
****0         print("|cFFFFFF00/healiq strategy|r - Show strategy commands")
          end
      end

      commands.strategy = function(subcommand, ...)
****0     if not HealIQ.db or not HealIQ.db.strategy then
****0         print("|cFFFF0000HealIQ|r Database not yet initialized")
****0         return
          end
          
****0     if subcommand == "list" then
****0         print("|cFF00FF00HealIQ Strategy Settings:|r")
****0         for setting, value in pairs(HealIQ.db.strategy) do
****0             local valueStr = tostring(value)
****0             if type(value) == "boolean" then
****0                 valueStr = value and "|cFF00FF00enabled|r" or "|cFFFF0000disabled|r"
                  else
****0                 valueStr = "|cFFFFFF00" .. valueStr .. "|r"
                  end
****0             print("  " .. setting .. ": " .. valueStr)
              end
****0     elseif subcommand == "set" then
****0         local setting = (...)
****0         local value = select(2, ...)
****0         if setting and value and HealIQ.db.strategy[setting] ~= nil then
****0             local oldValue = HealIQ.db.strategy[setting]
                  
                  -- Convert value based on current type
****0             if type(oldValue) == "boolean" then
****0                 if value == "true" or value == "1" or value == "on" then
****0                     HealIQ.db.strategy[setting] = true
****0                 elseif value == "false" or value == "0" or value == "off" then
****0                     HealIQ.db.strategy[setting] = false
                      else
****0                     print("|cFFFF0000HealIQ|r Invalid boolean value. Use true/false, 1/0, or on/off")
****0                     return
                      end
****0             elseif type(oldValue) == "number" then
****0                 local numValue = tonumber(value)
****0                 if numValue then
****0                     HealIQ.db.strategy[setting] = numValue
                      else
****0                     print("|cFFFF0000HealIQ|r Invalid number value: " .. value)
****0                     return
                      end
                  else
****0                 print("|cFFFF0000HealIQ|r Cannot set setting of type: " .. type(oldValue))
****0                 return
                  end
                  
****0             print("|cFF00FF00HealIQ|r Strategy setting '" .. setting .. "' set to " .. tostring(HealIQ.db.strategy[setting]))
                  
                  -- Force engine update to apply changes
****0             if HealIQ.Engine then
****0                 HealIQ.Engine:ForceUpdate()
                  end
              else
****0             print("|cFFFF0000HealIQ|r Unknown strategy setting: " .. tostring(setting))
              end
****0     elseif subcommand == "reset" then
              -- Reset strategy settings to defaults
****0         if HealIQ.db and HealIQ.db.strategy then
                  -- Get defaults from Core.lua
****0             local defaults = {
                      prioritizeEfflorescence = true,
                      maintainLifebloomOnTank = true,
                      lifebloomRefreshWindow = 4.5,
                      preferClearcastingRegrowth = true,
                      swiftmendWildGrowthCombo = true,
                      rejuvenationRampThreshold = 15,
                      avoidRandomRejuvenationDowntime = true,
                      useWrathForMana = true,
                      poolGroveGuardians = true,
                      emergencyNaturesSwiftness = true,
                      wildGrowthMinTargets = 3,
                      tranquilityMinTargets = 4,
                      efflorescenceMinTargets = 2,
                      flourishMinHots = 2,
                      recentDamageWindow = 3,
                      lowHealthThreshold = 0.3,
                  }
                  
****0             for setting, defaultValue in pairs(defaults) do
****0                 HealIQ.db.strategy[setting] = defaultValue
                  end
                  
****0             print("|cFF00FF00HealIQ|r Strategy settings reset to defaults")
                  
****0             if HealIQ.Engine then
****0                 HealIQ.Engine:ForceUpdate()
                  end
              end
          else
****0         print("|cFF00FF00HealIQ Strategy Commands:|r")
****0         print("|cFFFFFF00/healiq strategy list|r - List all strategy settings")
****0         print("|cFFFFFF00/healiq strategy set <setting> <value>|r - Set a strategy setting")
****0         print("|cFFFFFF00/healiq strategy reset|r - Reset all strategy settings to defaults")
****0         print("|cFFFFFF00Settings:|r prioritizeEfflorescence, maintainLifebloomOnTank,")
****0         print("  preferClearcastingRegrowth, swiftmendWildGrowthCombo, useWrathForMana,")
****0         print("  poolGroveGuardians, emergencyNaturesSwiftness, wildGrowthMinTargets,")
****0         print("  tranquilityMinTargets, efflorescenceMinTargets, flourishMinHots,")
****0         print("  recentDamageWindow, lowHealthThreshold, lifebloomRefreshWindow")
          end
      end

      commands.test = function(subcommand)
****0     if not HealIQ.db then
****0         print("|cFFFF0000HealIQ|r Database not yet initialized")
****0         return
          end
          
****0     if subcommand == "engine" then
****0         if HealIQ.Engine and HealIQ.db.rules then
****0             print("|cFF00FF00HealIQ|r Testing engine rules...")
****0             for rule in pairs(HealIQ.db.rules) do
****0                 local result = HealIQ.Engine:TestRule(rule)
****0                 local status = result and "|cFF00FF00PASS|r" or "|cFFFF0000FAIL|r"
****0                 print("  " .. rule .. ": " .. status)
                  end
              else
****0             print("|cFFFF0000HealIQ|r Engine or rules not yet initialized")
              end
****0     elseif subcommand == "queue" then
****0         if HealIQ.Engine then
****0             print("|cFF00FF00HealIQ|r Testing queue display...")
****0             local queue = HealIQ.Engine:EvaluateRulesQueue()
****0             if #queue > 0 then
****0                 print("  Queue contains " .. #queue .. " suggestions:")
****0                 for i, suggestion in ipairs(queue) do
****0                     print("    " .. i .. ". " .. suggestion.name)
                      end
                  else
****0                 print("  Queue is empty")
                  end
                  
                  -- Force UI update
****0             if HealIQ.UI then
****0                 HealIQ.UI:UpdateQueue(queue)
                  end
              else
****0             print("|cFFFF0000HealIQ|r Engine not yet initialized")
              end
****0     elseif subcommand == "ui" then
****0         if HealIQ.UI then
****0             HealIQ.UI:TestQueue()
              else
****0             print("|cFFFF0000HealIQ|r UI not yet initialized")
              end
****0     elseif subcommand == "targeting" then
****0         if HealIQ.Engine and HealIQ.UI then
****0             print("|cFF00FF00HealIQ|r Testing targeting suggestions...")
                  
                  -- Test each spell's targeting suggestions
****0             for spellName, spellData in pairs(HealIQ.Engine.SPELLS) do
****0                 local targetText = HealIQ.Engine:GetTargetingSuggestionsText(spellData)
****0                 local targetDesc = HealIQ.Engine:GetTargetingSuggestionsDescription(spellData)
                      
****0                 print("  " .. spellData.name .. ":")
****0                 if targetText then
****0                     print("    → " .. targetText)
****0                     if targetDesc then
****0                         print("    " .. targetDesc)
                          end
                      else
****0                     print("    → No targeting suggestion")
                      end
                  end
                  
                  -- Show a test suggestion with targeting
****0             local testSuggestion = HealIQ.Engine.SPELLS.REJUVENATION
****0             HealIQ.UI:UpdateSuggestion(testSuggestion)
****0             print("Test targeting display activated with Rejuvenation")
              else
****0             print("|cFFFF0000HealIQ|r Engine or UI not yet initialized")
              end
          else
****0         if HealIQ.UI then
****0             HealIQ.UI:TestDisplay()
              else
****0             print("|cFFFF0000HealIQ|r UI not yet initialized")
              end
          end
      end

      commands.debug = function()
****0     HealIQ.debug = not HealIQ.debug
****0     local status = HealIQ.debug and "enabled" or "disabled"
****0     print("|cFF00FF00HealIQ|r Debug mode " .. status)
      end

      commands.dump = function()
****0     local dump = HealIQ:GenerateDiagnosticDump()
          
          -- Print dump to chat (this would normally be saved to file)
****0     print("|cFF00FF00HealIQ|r Diagnostic dump generated:")
****0     print("|cFF888888" .. string.rep("-", 50) .. "|r")
          
          -- Split dump into lines and print each
****0     for line in dump:gmatch("[^\n]+") do
****0         print("|cFF888888" .. line .. "|r")
          end
          
****0     print("|cFF888888" .. string.rep("-", 50) .. "|r")
****0     print("|cFF00FF00HealIQ|r Diagnostic dump complete")
      end

      commands.reset = function()
****0     if not HealIQ.db then
****0         print("|cFFFF0000HealIQ|r Database not yet initialized")
****0         return
          end
          
****0     print("|cFF00FF00HealIQ|r Resetting all settings...")
          
          -- Reset to defaults
****0     HealIQ.db.enabled = true
****0     HealIQ.db.debug = false
          
****0     if HealIQ.db.ui then
****0         HealIQ.db.ui.scale = 1.0
****0         HealIQ.db.ui.x = 0
****0         HealIQ.db.ui.y = 0
****0         HealIQ.db.ui.locked = false
****0         HealIQ.db.ui.showIcon = true
****0         HealIQ.db.ui.showSpellName = true
****0         HealIQ.db.ui.showCooldown = true
****0         HealIQ.db.ui.showQueue = true
****0         HealIQ.db.ui.queueSize = 3
****0         HealIQ.db.ui.queueLayout = "horizontal"
****0         HealIQ.db.ui.queueSpacing = 8
****0         HealIQ.db.ui.queueScale = 0.75
****0         HealIQ.db.ui.minimapAngle = -math.pi/4
****0         HealIQ.db.ui.showPositionBorder = false
          end
          
****0     if HealIQ.db.rules then
****0         for rule in pairs(HealIQ.db.rules) do
****0             HealIQ.db.rules[rule] = true
              end
          end
          
****0     if HealIQ.UI then
****0         HealIQ.UI:RecreateFrames()
          end
          
****0     print("|cFF00FF00HealIQ|r Settings reset to defaults")
      end

      commands.reload = function()
****0     print("|cFF00FF00HealIQ|r Reloading addon configuration...")
          
          -- Reinitialize all modules
****0     if HealIQ.Tracker then
****0         HealIQ.Tracker:Initialize()
          end
          
****0     if HealIQ.Engine then
****0         HealIQ.Engine:Initialize()
          end
          
****0     if HealIQ.UI then
****0         HealIQ.UI:RecreateFrames()
          end
          
          -- Force an update
****0     if HealIQ.Engine then
****0         HealIQ.Engine:ForceUpdate()
          end
          
****0     print("|cFF00FF00HealIQ|r Addon reloaded successfully")
      end

      commands.status = function()
    3     print("|cFF00FF00HealIQ v" .. HealIQ.version .. " Status:|r")
          
    3     if not HealIQ.db then
****0         print("  |cFFFF0000Database not yet initialized|r")
****0         return
          end
          
    3     print("  Enabled: " .. (HealIQ.db.enabled and "|cFF00FF00Yes|r" or "|cFFFF0000No|r"))
    3     print("  Debug: " .. (HealIQ.debug and "|cFF00FF00Yes|r" or "|cFFFF0000No|r"))
          
    3     if HealIQ.db.ui then
    3         print("  UI Scale: " .. HealIQ.db.ui.scale)
    3         print("  UI Position: " .. HealIQ.db.ui.x .. ", " .. HealIQ.db.ui.y)
    3         print("  UI Locked: " .. (HealIQ.db.ui.locked and "|cFF00FF00Yes|r" or "|cFFFF0000No|r"))
    3         print("  Queue Display: " .. (HealIQ.db.ui.showQueue and "|cFF00FF00Enabled|r" or "|cFFFF0000Disabled|r"))
    3         print("  Queue Size: " .. (HealIQ.db.ui.queueSize or 3))
    3         print("  Queue Layout: " .. (HealIQ.db.ui.queueLayout or "horizontal"))
          else
****0         print("  UI: |cFFFF0000Not yet initialized|r")
          end
          
          -- Show current suggestion
    3     if HealIQ.Engine then
    3         local suggestion = HealIQ.Engine:GetCurrentSuggestion()
    3         if suggestion then
****0             print("  Current Suggestion: |cFF00FF00" .. suggestion.name .. "|r")
              else
    3             print("  Current Suggestion: |cFFFF0000None|r")
              end
              
              -- Show current queue
    3         local queue = HealIQ.Engine:GetCurrentQueue()
    3         if queue and #queue > 0 then
****0             local names = {}
****0             for i, queueSuggestion in ipairs(queue) do
****0                 table.insert(names, queueSuggestion.name)
                  end
****0             print("  Current Queue: |cFF00FF00" .. table.concat(names, " → ") .. "|r")
              else
    3             print("  Current Queue: |cFFFF0000Empty|r")
              end
          else
****0         print("  Engine: |cFFFF0000Not yet initialized|r")
          end
          
          -- Show active rules
    3     if HealIQ.db.rules then
    3         local activeRules = {}
   45         for rule, enabled in pairs(HealIQ.db.rules) do
   42             if enabled then
   42                 table.insert(activeRules, rule)
                  end
              end
    3         print("  Active Rules: " .. (#activeRules > 0 and "|cFF00FF00" .. table.concat(activeRules, ", ") .. "|r" or "|cFFFF0000None|r"))
          else
****0         print("  Rules: |cFFFF0000Not yet initialized|r")
          end
          
          -- Show spec info
    3     local _, class = UnitClass("player")
    3     local specIndex = GetSpecialization()
****0     local specName = specIndex and GetSpecializationInfo(specIndex) or "Unknown"
****0     print("  Class: |cFF00FF00" .. class .. "|r")
****0     print("  Spec: |cFF00FF00" .. specName .. "|r")
****0     print("  In Combat: " .. (InCombatLockdown() and "|cFF00FF00Yes|r" or "|cFFFF0000No|r"))
          
          -- Show session statistics
****0     if HealIQ.sessionStats and HealIQ.sessionStats.startTime then
****0         print("  |cFF00FF00Session Statistics:|r")
****0         local duration = time() - HealIQ.sessionStats.startTime
****0         print("    Duration: " .. HealIQ:FormatDuration(duration))
****0         print("    Suggestions: " .. HealIQ.sessionStats.suggestions)
****0         print("    Rules Processed: " .. HealIQ.sessionStats.rulesProcessed)
****0         print("    Events Handled: " .. HealIQ.sessionStats.eventsHandled)
****0         print("    Errors Logged: " .. HealIQ.sessionStats.errorsLogged)
          end
          
          -- Show addon status
****0     local addonVersion = C_AddOns.GetAddOnMetadata("HealIQ", "Version") or "Unknown"
****0     print("  Addon Version: |cFF00FF00" .. addonVersion .. "|r")
      end

      -- Public configuration methods
   13 function Config:SetOption(category, option, value)
   46     if not HealIQ.db then
****0         return false
          end
          
   46     if category == "ui" and HealIQ.db.ui and HealIQ.db.ui[option] ~= nil then
   22         HealIQ.db.ui[option] = value
   22         return true
   24     elseif category == "rules" and HealIQ.db.rules and HealIQ.db.rules[option] ~= nil then
****0         HealIQ.db.rules[option] = value
****0         return true
   24     elseif category == "general" and HealIQ.db[option] ~= nil then
   24         HealIQ.db[option] = value
   24         return true
          end
****0     return false
      end

   13 function Config:GetOption(category, option)
   23     if not HealIQ.db then
****0         return nil
          end
          
   23     if category == "ui" and HealIQ.db.ui then
   11         return HealIQ.db.ui[option]
   12     elseif category == "rules" and HealIQ.db.rules then
****0         return HealIQ.db.rules[option]
   12     elseif category == "general" then
   12         return HealIQ.db[option]
          end
****0     return nil
      end

   13 function Config:ShowHelp()
****0     commands.help()
      end

      -- Expose commands for testing
    5 Config.commands = commands

    5 HealIQ.Config = Config

==============================================================================
Core.lua
==============================================================================
      -- HealIQ Core.lua
      -- Addon initialization, event registration, and saved variables

   13 local addonName, HealIQ = ...

      -- Create the main addon object
   13 HealIQ = HealIQ or {}
   13 HealIQ.version = "0.0.25"
   13 HealIQ.debug = true

      -- Default settings
   13 local defaults = {
   13     enabled = true,
   13     debug = true, -- Debug mode setting
   13     ui = {
   13         scale = 1.0,
   13         x = 0,
   13         y = 0,
   13         locked = false,
   13         showIcon = true,
   13         showSpellName = true,
   13         showCooldown = true,
   13         showQueue = true,
   13         showTargeting = true, -- Show targeting suggestions
   13         showTargetingIcon = true, -- Show targeting icon overlay
   13         queueSize = 3,
   13         queueLayout = "horizontal", -- horizontal or vertical
   13         queueSpacing = 8,
   13         queueScale = 0.75, -- Scale of queue icons relative to main icon
   13         minimapX = 10,
   13         minimapY = -10,
   13         minimapAngle = -math.pi/4, -- Default angle for minimap positioning
   13         showPositionBorder = false, -- Show frame positioning border
   13     },
   13     rules = {
              -- Existing rules
   13         wildGrowth = true,
   13         clearcasting = true,
   13         lifebloom = true,
   13         swiftmend = true,
   13         rejuvenation = true,
              
              -- Enhanced rules
   13         ironbark = true,
   13         efflorescence = true,
   13         tranquility = true,
   13         incarnationTree = true,
   13         naturesSwiftness = true,
   13         barkskin = true,
   13         flourish = true,
              
              -- New spells from strategy review
   13         groveGuardians = true,
   13         wrath = true,
   13     },
   13     strategy = {
              -- Healing strategy settings based on Wowhead guide
   13         prioritizeEfflorescence = true,          -- Keep Efflorescence active frequently
   13         maintainLifebloomOnTank = true,          -- Always keep Lifebloom on tank
   13         lifebloomRefreshWindow = 4.5,            -- Refresh Lifebloom in last 4.5s for bloom
   13         preferClearcastingRegrowth = true,       -- Prioritize Regrowth with Clearcasting
   13         swiftmendWildGrowthCombo = true,         -- Link Swiftmend and Wild Growth usage
   13         rejuvenationRampThreshold = 15,          -- Start ramping Rejuv when damage expected in 15s
   13         avoidRandomRejuvenationDowntime = true,  -- Don't cast random Rejuvs during downtime
   13         useWrathForMana = true,                  -- Fill downtime with Wrath for mana
   13         poolGroveGuardians = true,               -- Pool Grove Guardian charges for cooldowns
   13         emergencyNaturesSwiftness = true,       -- Use Nature's Swiftness for emergency heals
              
              -- Tunable thresholds
   13         wildGrowthMinTargets = 3,                -- Minimum targets damaged to suggest Wild Growth
   13         tranquilityMinTargets = 4,               -- Minimum targets damaged to suggest Tranquility
   13         efflorescenceMinTargets = 2,             -- Minimum targets damaged to suggest Efflorescence
   13         flourishMinHots = 2,                     -- Minimum expiring HoTs to suggest Flourish
   13         recentDamageWindow = 3,                  -- Time window to consider "recent damage" (seconds)
   13         lowHealthThreshold = 0.3,                -- Health percentage to consider "emergency"
   13     }
      }

      -- Initialize saved variables
   13 function HealIQ:InitializeDB()
          -- Ensure HealIQDB exists
   20     if not HealIQDB then
   10         HealIQDB = {}
          end
          
          -- Validate HealIQDB structure
   20     if type(HealIQDB) ~= "table" then
   10         HealIQDB = {}
   10         self:Message("HealIQ database was corrupted (type: " .. type(HealIQDB) .. "), resetting to defaults", true)
          end
          
          -- Check for version upgrade
   20     if HealIQDB.version ~= self.version then
   20         self:OnVersionUpgrade(HealIQDB.version, self.version)
   20         HealIQDB.version = self.version
          end
          
          -- Merge defaults with saved settings
  120     for key, value in pairs(defaults) do
  100         if HealIQDB[key] == nil then
  100             if type(value) == "table" then
   60                 HealIQDB[key] = {}
 1020                 for subkey, subvalue in pairs(value) do
  960                     HealIQDB[key][subkey] = subvalue
                      end
                  else
   40                 HealIQDB[key] = value
                  end
****0         elseif type(value) == "table" and type(HealIQDB[key]) == "table" then
                  -- Merge nested tables
****0             for subkey, subvalue in pairs(value) do
****0                 if HealIQDB[key][subkey] == nil then
****0                     HealIQDB[key][subkey] = subvalue
                      end
                  end
              end
          end
          
   20     self.db = HealIQDB
   20     self:Print("Database initialized with " .. self:CountSettings() .. " settings")
      end

      -- Handle version upgrades
   13 function HealIQ:OnVersionUpgrade(oldVersion, newVersion)
   40     if oldVersion then
   10         self:Message("HealIQ upgraded from v" .. oldVersion .. " to v" .. newVersion)
          else
   30         self:Message("HealIQ v" .. newVersion .. " - First time installation")
          end
      end

      -- Count settings for diagnostics
   13 function HealIQ:CountSettings()
   30     local count = 0
          local function countTable(t)
  110         local c = 0
 1270         for k, v in pairs(t) do
 1160             c = c + 1
 1160             if type(v) == "table" then
   80                 c = c + countTable(v)
                  end
              end
  110         return c
          end
          
   30     if self.db then
   30         count = countTable(self.db)
          end
          
   30     return count
      end

      -- Initialize session statistics
   13 function HealIQ:InitializeSessionStats()
****0     self.sessionStats = {
              startTime = time(),
              suggestions = 0,
              rulesProcessed = 0,
              errorsLogged = 0,
              eventsHandled = 0,
          }
      end

      -- Debug print function
   13 function HealIQ:Print(message)
   87     if self.debug then
    9         print("|cFF00FF00HealIQ:|r " .. tostring(message))
          end
      end












   13 function HealIQ:FormatDuration(seconds)
   21     local hours = math.floor(seconds / 3600)
   21     local minutes = math.floor((seconds % 3600) / 60)
   21     local secs = seconds % 60
          
   21     if hours > 0 then
    7         return string.format("%dh %dm %ds", hours, minutes, secs)
   14     elseif minutes > 0 then
    7         return string.format("%dm %ds", minutes, secs)
          else
    7         return string.format("%ds", secs)
          end
      end

      -- Error handling wrapper
   13 function HealIQ:SafeCall(func, ...)
   50     local success, result = pcall(func, ...)
   50     if not success then
   13         local errorMsg = tostring(result)
   13         print("|cFFFF0000HealIQ Error:|r " .. errorMsg)
   13         self:LogError("SafeCall Error: " .. errorMsg)
              
   13         if self.debug then
****0             print("|cFFFF0000Stack trace:|r " .. debugstack())
****0             self:DebugLog("Stack trace: " .. debugstack(), "ERROR")
              end
              
              -- Also report to WoW's error system for copyable errors
              -- This ensures errors appear in the default error frame
   13         if self.debug then
                  -- Construct a complete error message with context and stack trace
****0             local completeError = "HealIQ SafeCall Error: " .. errorMsg .. "\n" .. debugstack()
****0             geterrorhandler()(completeError)
              end
              
   13         return false, result
          end
   37     return true, result
      end

      -- User message function
   13 function HealIQ:Message(message, isError)
   50     local prefix = isError and "|cFFFF0000HealIQ Error:|r " or "|cFF00FF00HealIQ:|r "
   50     print(prefix .. tostring(message))
      end

      -- Main addon initialization
   13 function HealIQ:OnInitialize()
****0     self:SafeCall(function()
****0         self:InitializeDB()
****0         self:Print("HealIQ " .. self.version .. " loaded")
              
              -- Initialize session statistics
****0         if self.Logging then
****0             self.Logging:InitializeVariables()
              end
****0         self:InitializeSessionStats()
              
              -- Initialize modules
****0         if self.Tracker then
****0             self.Tracker:Initialize()
****0             self:DebugLog("Tracker module initialized")
              end
              
****0         if self.Engine then
****0             self.Engine:Initialize()
****0             self:DebugLog("Engine module initialized")
              end
              
****0         if self.UI then
****0             self.UI:Initialize()
****0             self:DebugLog("UI module initialized")
              end
              
****0         if self.Config then
****0             self.Config:Initialize()
****0             self:DebugLog("Config module initialized")
              end
              
****0         self:Message("HealIQ " .. self.version .. " initialized successfully")
****0         self:DebugLog("HealIQ initialization completed successfully", "INFO")
          end)
      end

      -- Event handling
   13 function HealIQ:OnEvent(event, ...)
****0     local args = {...}  -- Capture varargs for use in SafeCall
****0     self:SafeCall(function()
****0         if self.sessionStats then
****0             self.sessionStats.eventsHandled = self.sessionStats.eventsHandled + 1
              end
****0         self:DebugLog("Event received: " .. event)
              
****0         if event == "ADDON_LOADED" then
****0             local loadedAddon = args[1]
****0             if loadedAddon == addonName then
****0                 self:OnInitialize()
                  end
****0         elseif event == "PLAYER_LOGIN" then
****0             self:OnPlayerLogin()
****0         elseif event == "PLAYER_ENTERING_WORLD" then
****0             self:OnPlayerEnteringWorld()
              end
          end)
      end

   13 function HealIQ:OnPlayerLogin()
****0     self:SafeCall(function()
****0         self:Print("Player logged in")
****0         self:DebugLog("Player logged in", "INFO")
          end)
      end

   13 function HealIQ:OnPlayerEnteringWorld()
****0     self:SafeCall(function()
****0         self:Print("Player entering world")
****0         self:DebugLog("Player entering world", "INFO")
              
****0         if not self.db then
****0             self:DebugLog("Database not yet initialized during OnPlayerEnteringWorld", "WARN")
****0             return
              end
              
              -- Check if player is a Restoration Druid
****0         local _, class = UnitClass("player")
****0         if class == "DRUID" then
****0             local specIndex = GetSpecialization()
****0             if specIndex == 4 then -- Restoration spec
****0                 self:Print("Restoration Druid detected")
****0                 self:DebugLog("Restoration Druid detected - enabling addon", "INFO")
****0                 self.db.enabled = true
****0                 self:Message("HealIQ enabled for Restoration Druid")
                  else
****0                 self:Print("Not Restoration spec, addon disabled")
****0                 self:DebugLog("Not Restoration spec (spec: " .. (specIndex or "unknown") .. ") - disabling addon", "INFO")
****0                 self.db.enabled = false
****0                 self:Message("HealIQ disabled (not Restoration spec)")
                  end
              else
****0             self:Print("Not a Druid, addon disabled")
****0             self:DebugLog("Not a Druid (class: " .. (class or "unknown") .. ") - disabling addon", "INFO")
****0             self.db.enabled = false
****0             self:Message("HealIQ disabled (not a Druid)")
              end
          end)
      end

      -- Create event frame
   13 local eventFrame = CreateFrame("Frame")
   13 eventFrame:RegisterEvent("ADDON_LOADED")
   13 eventFrame:RegisterEvent("PLAYER_LOGIN")
   13 eventFrame:RegisterEvent("PLAYER_ENTERING_WORLD")
   26 eventFrame:SetScript("OnEvent", function(self, event, ...)
****0     HealIQ:OnEvent(event, ...)
      end)

      -- Make HealIQ globally accessible
   13 _G[addonName] = HealIQ

      -- Cleanup function for addon disable/reload
   13 function HealIQ:Cleanup()
****0     self:SafeCall(function()
****0         if self.UI then
****0             self.UI:Hide()
              end
              
****0         if self.Engine then
                  -- Stop update loop
****0             self.Engine:StopUpdateLoop()
              end
              
****0         self:Print("HealIQ cleanup completed")
          end)
      end

==============================================================================
Engine.lua
==============================================================================
      -- HealIQ Engine.lua
      -- Priority logic engine that determines the suggested spell

   13 local addonName, HealIQ = ...

   13 HealIQ.Engine = {}
   13 local Engine = HealIQ.Engine

      -- Targeting types and their associated icons
      -- Icon path constants
   13 local ICON_SELF = "Interface\\Icons\\Ability_Warrior_BattleShout"
   13 local ICON_TANK = "Interface\\Icons\\Ability_Warrior_DefensiveStance"
   13 local ICON_CURRENT_TARGET = "Interface\\Icons\\Ability_Hunter_MarkedForDeath"
   13 local ICON_FOCUS = "Interface\\Icons\\Spell_Shadow_Teleport"
   13 local ICON_PARTY_MEMBER = "Interface\\Icons\\Achievement_Guildperk_EverybodysFriend"
   13 local ICON_LOWEST_HEALTH = "Interface\\Icons\\Spell_ChargeNegative"
   13 local ICON_TARGET_OF_TARGET = "Interface\\Icons\\Ability_Hunter_SniperShot"
   13 local ICON_GROUND_TARGET = "Interface\\Icons\\Spell_Arcane_TeleportBoralus"

   13 local TARGET_TYPES = {
   13     SELF = {
   13         name = "Self",
   13         icon = ICON_SELF,
   13         description = "Cast on yourself"
   13     },
   13     TANK = {
   13         name = "Tank",
   13         icon = ICON_TANK,
   13         description = "Cast on main tank"
   13     },
   13     CURRENT_TARGET = {
   13         name = "Current Target",
   13         icon = ICON_CURRENT_TARGET,
   13         description = "Cast on current target"
   13     },
   13     FOCUS = {
   13         name = "Focus",
   13         icon = ICON_FOCUS,
   13         description = "Cast on focus target"
   13     },
   13     PARTY_MEMBER = {
   13         name = "Party Member",
   13         icon = ICON_PARTY_MEMBER,
   13         description = "Cast on any party member"
   13     },
   13     LOWEST_HEALTH = {
   13         name = "Lowest Health",
   13         icon = ICON_LOWEST_HEALTH,
   13         description = "Target with lowest health"
   13     },
   13     TARGET_OF_TARGET = {
   13         name = "Target's Target",
   13         icon = ICON_TARGET_OF_TARGET,
   13         description = "Cast on target's target"
   13     },
   13     GROUND_TARGET = {
   13         name = "Ground Target",
   13         icon = ICON_GROUND_TARGET,
   13         description = "Place on ground"
   13     }
      }

      -- Spell information for suggestions with targeting recommendations
      -- Updated priorities based on Wowhead Restoration Druid guide
   13 local SPELLS = {
          -- Emergency/Major Cooldowns (Highest Priority)
   13     TRANQUILITY = {
   13         id = 740,
   13         name = "Tranquility",
   13         icon = "Interface\\Icons\\Spell_Nature_Tranquility",
   13         priority = 1,
   13         targets = {TARGET_TYPES.SELF}, -- Channel on self, affects all nearby allies
   13         targetingDescription = "Channel while positioned near injured allies"
   13     },
   13     INCARNATION_TREE = {
   13         id = 33891,
   13         name = "Incarnation",
   13         icon = "Interface\\Icons\\Spell_Druid_Incarnation",
   13         priority = 2,
   13         targets = {TARGET_TYPES.SELF}, -- Self-buff
   13         targetingDescription = "Activate when group healing is needed"
   13     },
   13     NATURES_SWIFTNESS = {
   13         id = 132158,
   13         name = "Nature's Swiftness",
   13         icon = "Interface\\Icons\\Spell_Nature_RavenForm",
   13         priority = 3,
   13         targets = {TARGET_TYPES.SELF}, -- Self-buff for next spell
   13         targetingDescription = "Use before emergency heal cast"
   13     },
          
          -- Core Maintenance (High Priority - keep these active)
   13     EFFLORESCENCE = {
   13         id = 145205,
   13         name = "Efflorescence",
   13         icon = "Interface\\Icons\\Ability_Druid_Efflorescence",
   13         priority = 4, -- Higher priority per guide: "keep active as frequently as possible"
   13         targets = {TARGET_TYPES.GROUND_TARGET}, -- Ground-targeted spell
   13         targetingDescription = "Place where group will be standing"
   13     },
   13     LIFEBLOOM = {
   13         id = 33763,
   13         name = "Lifebloom",
   13         icon = "Interface\\Icons\\INV_Misc_Herb_Felblossom",
   13         priority = 5, -- Higher priority per guide: "keep active on tank"
   13         targets = {TARGET_TYPES.TANK, TARGET_TYPES.FOCUS, TARGET_TYPES.CURRENT_TARGET}, -- Tank maintenance
   13         targetingDescription = "Keep active on main tank or focus target"
   13     },
          
          -- Proc-based spells (High Priority when available)
   13     REGROWTH = {
   13         id = 8936,
   13         name = "Regrowth",
   13         icon = "Interface\\Icons\\Spell_Nature_ResistNature",
   13         priority = 6, -- Higher priority when used with Clearcasting
   13         targets = {TARGET_TYPES.LOWEST_HEALTH, TARGET_TYPES.CURRENT_TARGET, TARGET_TYPES.TANK}, -- Direct heal
   13         targetingDescription = "Target needs immediate healing"
   13     },
          
          -- AoE Healing Combo
   13     SWIFTMEND = {
   13         id = 18562,
   13         name = "Swiftmend",
   13         icon = "Interface\\Icons\\INV_Relics_IdolofRejuvenation",
   13         priority = 7, -- Higher priority as setup for Wild Growth
   13         targets = {TARGET_TYPES.CURRENT_TARGET, TARGET_TYPES.LOWEST_HEALTH}, -- Target with HoTs
   13         targetingDescription = "Target must have Rejuvenation or Regrowth"
   13     },
   13     WILD_GROWTH = {
   13         id = 48438,
   13         name = "Wild Growth",
   13         icon = "Interface\\Icons\\Ability_Druid_WildGrowth",
   13         priority = 8, -- Often paired with Swiftmend
   13         targets = {TARGET_TYPES.PARTY_MEMBER, TARGET_TYPES.CURRENT_TARGET}, -- Smart heal around target
   13         targetingDescription = "Target near damaged party members"
   13     },
          
          -- Cooldown Management
   13     GROVE_GUARDIANS = {
   13         id = 102693,
   13         name = "Grove Guardians",
   13         icon = "Interface\\Icons\\Spell_Druid_Treant",
   13         priority = 9,
   13         targets = {TARGET_TYPES.SELF}, -- Self-activated with charges
   13         targetingDescription = "Pool charges for big cooldowns"
   13     },
   13     FLOURISH = {
   13         id = 197721,
   13         name = "Flourish",
   13         icon = "Interface\\Icons\\Spell_Druid_WildGrowth",
   13         priority = 10,
   13         targets = {TARGET_TYPES.SELF}, -- Affects all your HoTs
   13         targetingDescription = "Use when multiple HoTs are active"
   13     },
          
          -- Defensive/Utility
   13     IRONBARK = {
   13         id = 102342,
   13         name = "Ironbark",
   13         icon = "Interface\\Icons\\Spell_Druid_IronBark",
   13         priority = 11,
   13         targets = {TARGET_TYPES.TANK, TARGET_TYPES.CURRENT_TARGET, TARGET_TYPES.FOCUS}, -- Damage reduction
   13         targetingDescription = "Prioritize tanks or targets taking heavy damage"
   13     },
   13     BARKSKIN = {
   13         id = 22812,
   13         name = "Barkskin",
   13         icon = "Interface\\Icons\\Spell_Nature_StoneSkinTotem",
   13         priority = 12,
   13         targets = {TARGET_TYPES.SELF}, -- Self-defensive
   13         targetingDescription = "Use when taking damage"
   13     },
          
          -- Ramping HoTs (Lower priority during maintenance, higher during damage phases)
   13     REJUVENATION = {
   13         id = 774,
   13         name = "Rejuvenation",
   13         icon = "Interface\\Icons\\Spell_Nature_Rejuvenation",
   13         priority = 13,
   13         targets = {TARGET_TYPES.PARTY_MEMBER, TARGET_TYPES.CURRENT_TARGET, TARGET_TYPES.TANK}, -- Basic HoT
   13         targetingDescription = "Apply to targets without HoT coverage"
   13     },
          
          -- Filler/Mana Management
   13     WRATH = {
   13         id = 5176,
   13         name = "Wrath",
   13         icon = "Interface\\Icons\\Spell_Nature_AbolishMagic",
   13         priority = 14,
   13         targets = {TARGET_TYPES.CURRENT_TARGET}, -- Enemy target
   13         targetingDescription = "Use on enemies during downtime for mana restoration"
   13     },
      }

      -- Current suggestion state
   13 local currentSuggestion = nil
   13 local currentQueue = {}
   13 local lastUpdate = 0
   13 local updateInterval = 0.1 -- Update every 100ms

   13 function Engine:Initialize()
****0     HealIQ:SafeCall(function()
****0         self:StartUpdateLoop()
****0         HealIQ:Print("Engine initialized")
          end)
      end

   13 function Engine:StartUpdateLoop()
****0     local frame = CreateFrame("Frame", "HealIQUpdateFrame")
****0     frame:SetScript("OnUpdate", function(self, elapsed)
****0         Engine:OnUpdate(elapsed)
          end)
****0     self.updateFrame = frame
      end

   13 function Engine:StopUpdateLoop()
****0     if self.updateFrame then
****0         self.updateFrame:SetScript("OnUpdate", nil)
****0         self.updateFrame = nil
          end
      end

   13 function Engine:OnUpdate(elapsed)
****0     HealIQ:SafeCall(function()
****0         local currentTime = GetTime()
              
              -- Throttle updates
****0         if currentTime - lastUpdate < updateInterval then
****0             return
              end
              
****0         lastUpdate = currentTime
              
              -- Only suggest spells if addon is enabled and database is initialized
****0         if not HealIQ.db or not HealIQ.db.enabled then
****0             self:SetSuggestion(nil)
****0             self:SetQueue({})
****0             return
              end
              
              -- Check if we should be suggesting anything
****0         if not self:ShouldSuggest() then
****0             self:SetSuggestion(nil)
****0             self:SetQueue({})
****0             return
              end
              
              -- Evaluate priority rules
****0         local suggestion = self:EvaluateRules()
****0         local queue = self:EvaluateRulesQueue()
              
****0         self:SetSuggestion(suggestion)
****0         self:SetQueue(queue)
          end)
      end

   13 function Engine:ShouldSuggest()
          -- Only suggest if player is a Restoration Druid
****0     local _, class = UnitClass("player")
****0     if class ~= "DRUID" then
****0         return false
          end
          
****0     local specIndex = GetSpecialization()
****0     if specIndex ~= 4 then -- Not Restoration
****0         return false
          end
          
          -- Suggest in combat or when having a friendly target
****0     local inCombat = InCombatLockdown()
****0     local hasTarget = UnitExists("target")
****0     local targetIsFriendly = hasTarget and UnitIsFriend("player", "target")
          
****0     return inCombat or (hasTarget and targetIsFriendly)
      end

      -- Talent validation and detection system
   13 function Engine:GetOptimalTalents()
          -- Define optimal Restoration Druid talents for the healing strategy
          -- These are key talents that support the implemented healing strategy
****0     local optimalTalents = {
              -- Class Talents (essential for the strategy)
              {
                  name = "Wild Growth",
                  spellId = 48438,
                  description = "Essential AoE healing spell used in priority system",
                  category = "Core Healing",
****0             required = true
              },
              {
                  name = "Efflorescence",
                  spellId = 145205,
                  description = "Ground AoE healing - high priority in strategy",
                  category = "Core Healing",
****0             required = true
              },
              {
                  name = "Lifebloom",
                  spellId = 33763,
                  description = "Tank maintenance HoT with refresh timing logic",
                  category = "Core Healing",
****0             required = true
              },
              {
                  name = "Swiftmend",
                  spellId = 18562,
                  description = "Instant heal used for Wild Growth combo setup",
                  category = "Core Healing",
****0             required = true
              },
              {
                  name = "Nature's Swiftness",
                  spellId = 132158,
                  description = "Emergency instant cast enabler",
                  category = "Emergency",
****0             required = true
              },
              
              -- Spec Talents (highly recommended for optimal performance)
              {
                  name = "Flourish",
                  spellId = 197721,
                  description = "Extends multiple HoTs - part of priority system",
                  category = "HoT Management",
****0             required = false
              },
              {
                  name = "Grove Guardians",
                  spellId = 102693,
                  description = "Charge pooling for cooldown coordination",
                  category = "Cooldown Management",
****0             required = false
              },
              {
                  name = "Incarnation: Tree of Life",
                  spellId = 33891,
                  description = "Major healing cooldown in priority system",
                  category = "Major Cooldowns",
****0             required = false
              },
              {
                  name = "Tranquility",
                  spellId = 740,
                  description = "Raid healing cooldown - highest priority spell",
                  category = "Major Cooldowns",
****0             required = false
              }
          }
          
****0     return optimalTalents
      end

   13 function Engine:CheckTalentAvailability(spellId)
          -- Check if a talent/spell is known by the player
****0     if not spellId then
****0         return false
          end
          
          -- Use IsSpellKnown for passive talents and active abilities
****0     local isKnown = IsSpellKnown(spellId)
****0     if isKnown then
****0         return true
          end
          
          -- For some talents, check if they're learned via C_Spell.GetSpellName
****0     local spellName = C_Spell.GetSpellName(spellId)
****0     if spellName then
****0         return IsSpellKnown(spellId) or IsPlayerSpell(spellId)
          end
          
****0     return false
      end

   13 function Engine:GetTalentStatus()
****0     local talentStatus = {
              missing = {},
              present = {},
****0         categories = {}
          }
          
****0     local optimalTalents = self:GetOptimalTalents()
          
****0     for _, talent in ipairs(optimalTalents) do
****0         local isAvailable = self:CheckTalentAvailability(talent.spellId)
              
****0         if isAvailable then
****0             table.insert(talentStatus.present, talent)
              else
****0             table.insert(talentStatus.missing, talent)
              end
              
              -- Organize by category
****0         if not talentStatus.categories[talent.category] then
****0             talentStatus.categories[talent.category] = {missing = {}, present = {}}
              end
              
****0         if isAvailable then
****0             table.insert(talentStatus.categories[talent.category].present, talent)
              else
****0             table.insert(talentStatus.categories[talent.category].missing, talent)
              end
          end
          
****0     return talentStatus
      end

   13 function Engine:GetTalentRecommendations()
****0     local talentStatus = self:GetTalentStatus()
****0     local recommendations = {
              critical = {},
              suggested = {},
****0         summary = ""
          }
          
          -- Separate critical missing talents from suggested ones
****0     for _, talent in ipairs(talentStatus.missing) do
****0         if talent.required then
****0             table.insert(recommendations.critical, talent)
              else
****0             table.insert(recommendations.suggested, talent)
              end
          end
          
          -- Generate summary text
****0     local criticalCount = #recommendations.critical
****0     local suggestedCount = #recommendations.suggested
          
****0     if criticalCount > 0 then
****0         recommendations.summary = string.format("Missing %d critical talents for optimal healing", criticalCount)
****0     elseif suggestedCount > 0 then
****0         recommendations.summary = string.format("Missing %d recommended talents for enhanced healing", suggestedCount)
          else
****0         recommendations.summary = "All optimal talents are available!"
          end
          
****0     return recommendations
      end

   13 function Engine:EvaluateRules()
****0     local tracker = HealIQ.Tracker
****0     if not tracker then
****0         return nil
          end
          
****0     if not HealIQ.db or not HealIQ.db.rules then
****0         return nil
          end
          
****0     local suggestions = {}
****0     local strategy = HealIQ.db.strategy or {}
****0     HealIQ:DebugLog("Starting rule evaluation with enhanced strategy")
          
          -- Rule 1: Emergency/Major Cooldowns (Highest Priority)
          
          -- Tranquility if off cooldown and enough allies recently damaged
****0     if HealIQ.db.rules.tranquility and tracker:ShouldUseTranquility() then
****0         table.insert(suggestions, SPELLS.TRANQUILITY)
****0         HealIQ:DebugLog("Rule triggered: Tranquility")
****0         if HealIQ.sessionStats then
****0             HealIQ.sessionStats.rulesProcessed = HealIQ.sessionStats.rulesProcessed + 1
              end
          end
          
          -- Incarnation: Tree of Life for high damage phases
****0     if HealIQ.db.rules.incarnationTree and tracker:ShouldUseIncarnation() then
****0         table.insert(suggestions, SPELLS.INCARNATION_TREE)
****0         HealIQ:DebugLog("Rule triggered: Incarnation Tree")
****0         if HealIQ.sessionStats then
****0             HealIQ.sessionStats.rulesProcessed = HealIQ.sessionStats.rulesProcessed + 1
              end
          end
          
          -- Nature's Swiftness for emergency situations (low health targets)
****0     if HealIQ.db.rules.naturesSwiftness and tracker:ShouldUseNaturesSwiftness() then
****0         table.insert(suggestions, SPELLS.NATURES_SWIFTNESS)
****0         HealIQ:DebugLog("Rule triggered: Nature's Swiftness")
****0         if HealIQ.sessionStats then
****0             HealIQ.sessionStats.rulesProcessed = HealIQ.sessionStats.rulesProcessed + 1
              end
          end
          
          -- Rule 2: Core Maintenance (High Priority - keep these active)
          
          -- Efflorescence - "keep active as frequently as possible"
****0     if HealIQ.db.rules.efflorescence and strategy.prioritizeEfflorescence and tracker:ShouldUseEfflorescence() then
****0         table.insert(suggestions, SPELLS.EFFLORESCENCE)
****0         HealIQ:DebugLog("Rule triggered: Efflorescence (prioritized)")
****0         if HealIQ.sessionStats then
****0             HealIQ.sessionStats.rulesProcessed = HealIQ.sessionStats.rulesProcessed + 1
              end
          end
          
          -- Lifebloom maintenance on tank - higher priority
****0     if UnitExists("target") and UnitIsFriend("player", "target") then
****0         local lifeboomInfo = tracker:GetTargetHotInfo("lifebloom")
****0         local hasLifebloom = lifeboomInfo and lifeboomInfo.active
****0         local refreshWindow = strategy.lifebloomRefreshWindow or 4.5
              
              -- Check if target is a tank or important target
****0         local isTank = UnitGroupRolesAssigned("target") == "TANK"
****0         local isFocus = UnitIsUnit("target", "focus")
              
****0         if HealIQ.db.rules.lifebloom and strategy.maintainLifebloomOnTank and (isTank or isFocus) then
                  -- Suggest if no Lifebloom or needs refresh
****0             if not hasLifebloom then
****0                 table.insert(suggestions, SPELLS.LIFEBLOOM)
****0                 HealIQ:DebugLog("Rule triggered: Lifebloom (missing on tank)")
****0                 if HealIQ.sessionStats then
****0                     HealIQ.sessionStats.rulesProcessed = HealIQ.sessionStats.rulesProcessed + 1
                      end
****0             elseif hasLifebloom and lifeboomInfo.remaining < refreshWindow then
****0                 table.insert(suggestions, SPELLS.LIFEBLOOM)
****0                 HealIQ:DebugLog("Rule triggered: Lifebloom (refresh for bloom)")
****0                 if HealIQ.sessionStats then
****0                     HealIQ.sessionStats.rulesProcessed = HealIQ.sessionStats.rulesProcessed + 1
                      end
                  end
              end
          end
          
          -- Rule 3: Proc-based spells (High Priority when available)
          
          -- Clearcasting active → Prioritize Regrowth
****0     if HealIQ.db.rules.clearcasting and strategy.preferClearcastingRegrowth and tracker:HasClearcasting() then
****0         table.insert(suggestions, SPELLS.REGROWTH)
****0         HealIQ:DebugLog("Rule triggered: Regrowth (Clearcasting proc)")
****0         if HealIQ.sessionStats then
****0             HealIQ.sessionStats.rulesProcessed = HealIQ.sessionStats.rulesProcessed + 1
              end
          end
          
          -- Rule 4: AoE Healing Combo (Swiftmend → Wild Growth)
          
          -- Swiftmend setup for Wild Growth combo
****0     if HealIQ.db.rules.swiftmend and strategy.swiftmendWildGrowthCombo and tracker:CanSwiftmend() then
****0         local recentDamageCount = tracker:GetRecentDamageCount()
****0         local wildGrowthReady = tracker:IsSpellReady("wildGrowth")
****0         local minTargets = strategy.wildGrowthMinTargets or 3
              
              -- Suggest Swiftmend if Wild Growth is ready and multiple targets need healing
****0         if wildGrowthReady and recentDamageCount >= minTargets then
****0             table.insert(suggestions, SPELLS.SWIFTMEND)
****0             HealIQ:DebugLog("Rule triggered: Swiftmend (Wild Growth combo setup)")
****0             if HealIQ.sessionStats then
****0                 HealIQ.sessionStats.rulesProcessed = HealIQ.sessionStats.rulesProcessed + 1
                  end
              end
          end
          
          -- Wild Growth if off cooldown and enough targets damaged
****0     if HealIQ.db.rules.wildGrowth and tracker:IsSpellReady("wildGrowth") then
****0         local recentDamageCount = tracker:GetRecentDamageCount()
****0         local minTargets = strategy.wildGrowthMinTargets or 3
****0         if recentDamageCount >= minTargets then
****0             table.insert(suggestions, SPELLS.WILD_GROWTH)
****0             HealIQ:DebugLog("Rule triggered: Wild Growth (recent damage: " .. recentDamageCount .. ")")
****0             if HealIQ.sessionStats then
****0                 HealIQ.sessionStats.rulesProcessed = HealIQ.sessionStats.rulesProcessed + 1
                  end
              end
          end
          
          -- Rule 5: Cooldown Management
          
          -- Grove Guardians - pool charges for big cooldowns
****0     if HealIQ.db.rules.groveGuardians and strategy.poolGroveGuardians and tracker:ShouldUseGroveGuardians() then
****0         table.insert(suggestions, SPELLS.GROVE_GUARDIANS)
****0         HealIQ:DebugLog("Rule triggered: Grove Guardians")
****0         if HealIQ.sessionStats then
****0             HealIQ.sessionStats.rulesProcessed = HealIQ.sessionStats.rulesProcessed + 1
              end
          end
          
          -- Flourish if available and multiple HoTs are expiring
****0     if HealIQ.db.rules.flourish and tracker:ShouldUseFlourish() then
****0         table.insert(suggestions, SPELLS.FLOURISH)
****0         HealIQ:DebugLog("Rule triggered: Flourish")
****0         if HealIQ.sessionStats then
****0             HealIQ.sessionStats.rulesProcessed = HealIQ.sessionStats.rulesProcessed + 1
              end
          end
          
          -- Rule 6: Defensive/Utility
          
          -- Ironbark for damage reduction on target
****0     if HealIQ.db.rules.ironbark and tracker:ShouldUseIronbark() then
****0         table.insert(suggestions, SPELLS.IRONBARK)
****0         HealIQ:DebugLog("Rule triggered: Ironbark")
****0         if HealIQ.sessionStats then
****0             HealIQ.sessionStats.rulesProcessed = HealIQ.sessionStats.rulesProcessed + 1
              end
          end
          
          -- Barkskin for self-defense
****0     if HealIQ.db.rules.barkskin and tracker:ShouldUseBarkskin() then
****0         table.insert(suggestions, SPELLS.BARKSKIN)
****0         HealIQ:DebugLog("Rule triggered: Barkskin")
****0         if HealIQ.sessionStats then
****0             HealIQ.sessionStats.rulesProcessed = HealIQ.sessionStats.rulesProcessed + 1
              end
          end
          
          -- Rule 7: Ramping HoTs (Context-dependent priority)
          
          -- Rejuvenation logic - avoid random casts during downtime
****0     if UnitExists("target") and UnitIsFriend("player", "target") then
****0         local rejuvInfo = tracker:GetTargetHotInfo("rejuvenation")
****0         local hasRejuv = rejuvInfo and rejuvInfo.active
              
****0         if HealIQ.db.rules.rejuvenation and not hasRejuv then
****0             local inCombat = InCombatLockdown()
****0             local recentDamageCount = tracker:GetRecentDamageCount()
                  
                  -- Only suggest Rejuvenation if in combat or damage is expected
****0             if inCombat or recentDamageCount > 0 or not strategy.avoidRandomRejuvenationDowntime then
****0                 table.insert(suggestions, SPELLS.REJUVENATION)
****0                 HealIQ:DebugLog("Rule triggered: Rejuvenation (target missing)")
****0                 if HealIQ.sessionStats then
****0                     HealIQ.sessionStats.rulesProcessed = HealIQ.sessionStats.rulesProcessed + 1
                      end
                  end
              end
          end
          
          -- Rule 8: Filler/Mana Management
          
          -- Wrath for mana restoration during downtime
****0     if HealIQ.db.rules.wrath and strategy.useWrathForMana and tracker:ShouldUseWrath() then
****0         table.insert(suggestions, SPELLS.WRATH)
****0         HealIQ:DebugLog("Rule triggered: Wrath (mana filler)")
****0         if HealIQ.sessionStats then
****0             HealIQ.sessionStats.rulesProcessed = HealIQ.sessionStats.rulesProcessed + 1
              end
          end
          
****0     HealIQ:DebugLog("Rule evaluation completed, " .. #suggestions .. " suggestions found")
          
          -- Return the top suggestion for backward compatibility
****0     return suggestions[1] or nil
      end

      -- New function to get multiple suggestions for queue display
   13 function Engine:EvaluateRulesQueue()
****0     local tracker = HealIQ.Tracker
****0     if not tracker then
****0         return {}
          end
          
****0     if not HealIQ.db or not HealIQ.db.rules then
****0         return {}
          end
          
****0     local suggestions = {}
****0     local strategy = HealIQ.db.strategy or {}
          
          -- Use the same rule evaluation logic as the main function for consistency
          -- This ensures the queue shows the same priority order as the main suggestion
          
          -- Rule 1: Emergency/Major Cooldowns
****0     if HealIQ.db.rules.tranquility and tracker:ShouldUseTranquility() then
****0         table.insert(suggestions, SPELLS.TRANQUILITY)
          end
          
****0     if HealIQ.db.rules.incarnationTree and tracker:ShouldUseIncarnation() then
****0         table.insert(suggestions, SPELLS.INCARNATION_TREE)
          end
          
****0     if HealIQ.db.rules.naturesSwiftness and tracker:ShouldUseNaturesSwiftness() then
****0         table.insert(suggestions, SPELLS.NATURES_SWIFTNESS)
          end
          
          -- Rule 2: Core Maintenance
****0     if HealIQ.db.rules.efflorescence and strategy.prioritizeEfflorescence and tracker:ShouldUseEfflorescence() then
****0         table.insert(suggestions, SPELLS.EFFLORESCENCE)
          end
          
          -- Lifebloom maintenance logic
****0     if UnitExists("target") and UnitIsFriend("player", "target") then
****0         local lifeboomInfo = tracker:GetTargetHotInfo("lifebloom")
****0         local hasLifebloom = lifeboomInfo and lifeboomInfo.active
****0         local refreshWindow = strategy.lifebloomRefreshWindow or 4.5
****0         local isTank = UnitGroupRolesAssigned("target") == "TANK"
****0         local isFocus = UnitIsUnit("target", "focus")
              
****0         if HealIQ.db.rules.lifebloom and strategy.maintainLifebloomOnTank and (isTank or isFocus) then
****0             if not hasLifebloom or (hasLifebloom and lifeboomInfo.remaining < refreshWindow) then
****0                 table.insert(suggestions, SPELLS.LIFEBLOOM)
                  end
              end
          end
          
          -- Rule 3: Proc-based spells
****0     if HealIQ.db.rules.clearcasting and strategy.preferClearcastingRegrowth and tracker:HasClearcasting() then
****0         table.insert(suggestions, SPELLS.REGROWTH)
          end
          
          -- Rule 4: AoE Healing Combo
****0     if HealIQ.db.rules.swiftmend and strategy.swiftmendWildGrowthCombo and tracker:CanSwiftmend() then
****0         local recentDamageCount = tracker:GetRecentDamageCount()
****0         local wildGrowthReady = tracker:IsSpellReady("wildGrowth")
****0         local minTargets = strategy.wildGrowthMinTargets or 3
              
****0         if wildGrowthReady and recentDamageCount >= minTargets then
****0             table.insert(suggestions, SPELLS.SWIFTMEND)
              end
          end
          
****0     if HealIQ.db.rules.wildGrowth and tracker:IsSpellReady("wildGrowth") then
****0         local recentDamageCount = tracker:GetRecentDamageCount()
****0         local minTargets = strategy.wildGrowthMinTargets or 3
****0         if recentDamageCount >= minTargets then
****0             table.insert(suggestions, SPELLS.WILD_GROWTH)
              end
          end
          
          -- Rule 5: Cooldown Management
****0     if HealIQ.db.rules.groveGuardians and strategy.poolGroveGuardians and tracker:ShouldUseGroveGuardians() then
****0         table.insert(suggestions, SPELLS.GROVE_GUARDIANS)
          end
          
****0     if HealIQ.db.rules.flourish and tracker:ShouldUseFlourish() then
****0         table.insert(suggestions, SPELLS.FLOURISH)
          end
          
          -- Rule 6: Defensive/Utility
****0     if HealIQ.db.rules.ironbark and tracker:ShouldUseIronbark() then
****0         table.insert(suggestions, SPELLS.IRONBARK)
          end
          
****0     if HealIQ.db.rules.barkskin and tracker:ShouldUseBarkskin() then
****0         table.insert(suggestions, SPELLS.BARKSKIN)
          end
          
          -- Rule 7: Ramping HoTs
****0     if UnitExists("target") and UnitIsFriend("player", "target") then
****0         local rejuvInfo = tracker:GetTargetHotInfo("rejuvenation")
****0         local hasRejuv = rejuvInfo and rejuvInfo.active
              
****0         if HealIQ.db.rules.rejuvenation and not hasRejuv then
****0             local inCombat = InCombatLockdown()
****0             local recentDamageCount = tracker:GetRecentDamageCount()
                  
****0             if inCombat or recentDamageCount > 0 or not strategy.avoidRandomRejuvenationDowntime then
****0                 table.insert(suggestions, SPELLS.REJUVENATION)
                  end
              end
          end
          
          -- Rule 8: Filler/Mana Management
****0     if HealIQ.db.rules.wrath and strategy.useWrathForMana and tracker:ShouldUseWrath() then
****0         table.insert(suggestions, SPELLS.WRATH)
          end
          
          -- Return up to the configured queue size suggestions
****0     if HealIQ.db and HealIQ.db.ui then
****0         local queueSize = HealIQ.db.ui.queueSize or 3
****0         local queue = {}
****0         for i = 1, math.min(queueSize, #suggestions) do
****0             table.insert(queue, suggestions[i])
              end
****0         return queue
          else
              -- Fallback if UI config not available
****0         local queue = {}
****0         for i = 1, math.min(3, #suggestions) do
****0             table.insert(queue, suggestions[i])
              end
****0         return queue
          end
      end

      -- Targeting evaluation functions
   13 function Engine:EvaluateTargetingSuggestion(spell)
****0     if not spell or not spell.targets then
****0         return nil
          end
          
          local bestTarget = nil
****0     local targetingContext = {
              hasTarget = UnitExists("target"),
              targetIsFriendly = UnitExists("target") and UnitIsFriend("player", "target"),
              hasFocus = UnitExists("focus"),
              focusIsFriendly = UnitExists("focus") and UnitIsFriend("player", "focus"),
              inParty = IsInGroup(),
              inRaid = IsInRaid(),
****0         inCombat = InCombatLockdown()
          }
          
          -- Evaluate each potential target type for this spell
****0     for _, targetType in ipairs(spell.targets) do
****0         local targetPriority = self:EvaluateTargetPriority(targetType, spell, targetingContext)
****0         if targetPriority > 0 and (not bestTarget or targetPriority > bestTarget.priority) then
****0             bestTarget = {
                      type = targetType,
                      priority = targetPriority,
****0                 available = true
                  }
              end
          end
          
****0     return bestTarget
      end

      -- Target priority evaluation lookup table for better performance
   13 local TARGET_PRIORITY_EVALUATORS = {
   13     [TARGET_TYPES.SELF] = function(context)
****0         return 100 -- Always available
          end,
          
   13     [TARGET_TYPES.CURRENT_TARGET] = function(context)
****0         if context.targetIsFriendly then
****0             return 90 -- High priority if we have a friendly target
              else
****0             return 0 -- Not available
              end
          end,
          
   13     [TARGET_TYPES.FOCUS] = function(context)
****0         if context.focusIsFriendly then
****0             return 85 -- Good priority for focus target
              else
****0             return 0 -- Not available
              end
          end,
          
   13     [TARGET_TYPES.TANK] = function(context)
              -- Check if current target or focus is a tank
****0         local targetIsTank = context.targetIsFriendly and UnitGroupRolesAssigned("target") == "TANK"
****0         local focusIsTank = context.focusIsFriendly and UnitGroupRolesAssigned("focus") == "TANK"
              
****0         if targetIsTank then
****0             return 95 -- Very high priority for tank targeting spells
****0         elseif focusIsTank then
****0             return 90 -- Also high priority if focus is tank
****0         elseif context.inParty or context.inRaid then
****0             return 70 -- Medium priority, assume tank exists in group
              else
****0             return 0 -- No tank available
              end
          end,
          
   13     [TARGET_TYPES.PARTY_MEMBER] = function(context)
****0         if context.inParty or context.inRaid then
****0             return 75 -- Good priority if in group
              else
****0             return 0 -- Not in party
              end
          end,
          
   13     [TARGET_TYPES.LOWEST_HEALTH] = function(context)
              -- We can't read health during combat due to WoW API limitations.
              -- As a fallback, we prioritize the current target if it is friendly,
              -- assuming it needs healing. If in a party or raid, we assign medium
              -- priority, as manual targeting may be required. If neither condition
              -- is met, we return 0, indicating no one is available to heal.
****0         if context.targetIsFriendly then
****0             return 80 -- Assume current target needs healing
****0         elseif context.inParty or context.inRaid then
****0             return 60 -- Medium priority, would need to target manually
              else
****0             return 0 -- No one to heal
              end
          end,
          
   13     [TARGET_TYPES.TARGET_OF_TARGET] = function(context)
****0         if context.hasTarget and UnitExists("targettarget") and UnitIsFriend("player", "targettarget") then
****0             return 70 -- Available and useful for some situations
              else
****0             return 0 -- Not available
              end
          end,
          
   13     [TARGET_TYPES.GROUND_TARGET] = function(context)
****0         return 80 -- Always available for ground-targeted spells
          end
      }

   13 function Engine:EvaluateTargetPriority(targetType, spell, context)
          --[[
              Evaluate the priority score for a given target type based on the spell and context.
              
              Scoring System:
              - Priority scores range from 0 to 100, where higher values indicate better target choices.
              - A score of 0 means the target type is not available or applicable.
              - Scores are assigned based on contextual factors such as whether the target is friendly,
                whether the player is in a group, and the type of spell being cast.
              
              Parameters:
              - targetType: The type of target being evaluated (e.g., SELF, CURRENT_TARGET, FOCUS).
              - spell: The spell being considered for casting, which includes its target types.
              - context: A table containing contextual information (e.g., whether the player is in combat,
                whether a target exists, and whether the target is friendly).
              
              Returns:
              - A numerical priority score (0-100) indicating the suitability of the target type.
          ]]
          
****0     local evaluator = TARGET_PRIORITY_EVALUATORS[targetType]
****0     if evaluator then
****0         return evaluator(context)
          end
          
****0     return 0 -- Unknown target type
      end

   13 function Engine:GetTargetingSuggestionsText(suggestion)
****0     if not suggestion then
****0         return nil
          end
          
****0     local targetSuggestion = self:EvaluateTargetingSuggestion(suggestion)
****0     if targetSuggestion and targetSuggestion.type then
****0         return targetSuggestion.type.name
          end
          
****0     return nil
      end

   13 function Engine:GetTargetingSuggestionsIcon(suggestion)
****0     if not suggestion then
****0         return nil
          end
          
****0     local targetSuggestion = self:EvaluateTargetingSuggestion(suggestion)
****0     if targetSuggestion and targetSuggestion.type then
****0         return targetSuggestion.type.icon
          end
          
****0     return nil
      end

   13 function Engine:GetTargetingSuggestionsDescription(suggestion)
****0     if not suggestion then
****0         return nil
          end
          
****0     local targetSuggestion = self:EvaluateTargetingSuggestion(suggestion)
****0     if targetSuggestion and targetSuggestion.type then
****0         return targetSuggestion.type.description
          end
          
****0     return suggestion.targetingDescription or nil
      end

   13 function Engine:SetSuggestion(suggestion)
****0     if suggestion ~= currentSuggestion then
****0         currentSuggestion = suggestion
              
              -- Notify UI of change
****0         if HealIQ.UI then
****0             HealIQ.UI:UpdateSuggestion(suggestion)
              end
              
              -- Debug output (only when debug mode is on)
****0         if HealIQ.debug then
****0             if suggestion then
****0                 local targetText = self:GetTargetingSuggestionsText(suggestion)
****0                 local suggestionText = suggestion.name
****0                 if targetText then
****0                     suggestionText = suggestionText .. " → " .. targetText
                      end
****0                 HealIQ:Print("Suggesting: " .. suggestionText)
****0                 HealIQ:DebugLog("Generated suggestion: " .. suggestion.name .. " (priority: " .. suggestion.priority .. ", target: " .. (targetText or "none") .. ")")
                  else
****0                 HealIQ:Print("No suggestion")
****0                 HealIQ:DebugLog("No suggestion generated")
                  end
              end
              
              -- Track suggestion stats
****0         if suggestion and HealIQ.sessionStats then
****0             HealIQ.sessionStats.suggestions = HealIQ.sessionStats.suggestions + 1
              end
          end
      end

   13 function Engine:SetQueue(queue)
          -- Compare queue arrays for changes
****0     local changed = false
****0     if #queue ~= #currentQueue then
****0         changed = true
          else
****0         for i, suggestion in ipairs(queue) do
****0             if not currentQueue[i] or suggestion.id ~= currentQueue[i].id then
****0                 changed = true
                      break
                  end
              end
          end
          
****0     if changed then
****0         currentQueue = queue
              
              -- Notify UI of queue change
****0         if HealIQ.UI then
****0             HealIQ.UI:UpdateQueue(queue)
              end
              
              -- Debug output (only when debug mode is on)
****0         if HealIQ.debug then
****0             if #queue > 0 then
****0                 local names = {}
****0                 for i, suggestion in ipairs(queue) do
****0                     table.insert(names, suggestion.name)
                      end
****0                 HealIQ:Print("Queue updated: " .. table.concat(names, " → "))
****0                 HealIQ:DebugLog("Queue updated (" .. #queue .. " items): " .. table.concat(names, " → "))
                  else
****0                 HealIQ:Print("Queue cleared")
****0                 HealIQ:DebugLog("Queue cleared")
                  end
              end
          end
      end

   13 function Engine:GetCurrentSuggestion()
    3     return currentSuggestion
      end

   13 function Engine:GetCurrentQueue()
    3     return currentQueue
      end

   13 function Engine:ForceUpdate()
****0     lastUpdate = 0
****0     self:OnUpdate(0)
      end

      -- Public rule evaluation functions for testing
   13 function Engine:TestRule(ruleName, ...)
****0     local tracker = HealIQ.Tracker
****0     if not tracker then
****0         return false
          end
          
****0     if ruleName == "wildGrowth" then
****0         return tracker:IsSpellReady("wildGrowth") and tracker:GetRecentDamageCount() >= 3
****0     elseif ruleName == "clearcasting" then
****0         return tracker:HasClearcasting()
****0     elseif ruleName == "lifebloom" then
****0         if not UnitExists("target") then return false end
****0         local lifeboomInfo = tracker:GetTargetHotInfo("lifebloom")
****0         return lifeboomInfo and lifeboomInfo.active and lifeboomInfo.remaining < 4
****0     elseif ruleName == "swiftmend" then
****0         return tracker:CanSwiftmend()
****0     elseif ruleName == "rejuvenation" then
****0         if not UnitExists("target") then return false end
****0         local rejuvInfo = tracker:GetTargetHotInfo("rejuvenation")
****0         return not rejuvInfo or not rejuvInfo.active
****0     elseif ruleName == "ironbark" then
****0         return tracker:ShouldUseIronbark()
****0     elseif ruleName == "efflorescence" then
****0         return tracker:ShouldUseEfflorescence()
****0     elseif ruleName == "tranquility" then
****0         return tracker:ShouldUseTranquility()
****0     elseif ruleName == "flourish" then
****0         return tracker:ShouldUseFlourish()
****0     elseif ruleName == "incarnationTree" then
****0         return tracker:ShouldUseIncarnation()
****0     elseif ruleName == "naturesSwiftness" then
****0         return tracker:ShouldUseNaturesSwiftness()
****0     elseif ruleName == "barkskin" then
****0         return tracker:ShouldUseBarkskin()
****0     elseif ruleName == "groveGuardians" then
****0         return tracker:ShouldUseGroveGuardians()
****0     elseif ruleName == "wrath" then
****0         return tracker:ShouldUseWrath()
          end
          
****0     return false
      end

   13 HealIQ.Engine = Engine
   13 HealIQ.Engine.TARGET_TYPES = TARGET_TYPES
   13 HealIQ.Engine.SPELLS = SPELLS

==============================================================================
Logging.lua
==============================================================================
      -- HealIQ Logging.lua
      -- Session statistics and diagnostic functionality

   13 local addonName, HealIQ = ...

      -- Create the Logging module
   13 HealIQ.Logging = {}
   13 local Logging = HealIQ.Logging

      -- Initialize logging-related variables on HealIQ object
   13 function Logging:InitializeVariables()
          -- Initialize session stats if they don't exist
   10     HealIQ.sessionStats = HealIQ.sessionStats or {
   10         startTime = nil,
   10         suggestions = 0,
   10         rulesProcessed = 0,
   10         errorsLogged = 0,
   10         eventsHandled = 0,
   10     }
      end

      -- Initialize session statistics
   13 function HealIQ:InitializeSessionStats()
   18     if self.sessionStats then
   14         self.sessionStats.startTime = time()
          end
      end

      -- Debug logging function - prints to chat in real-time when debug mode is enabled
   13 function HealIQ:DebugLog(message, level)
   45     if not self.debug then
   13         return
          end
          
   32     level = level or "DEBUG"
   32     local timestamp = date("%H:%M:%S")
   32     local logEntry = string.format("[%s] [%s] %s", timestamp, level, tostring(message))
          
          -- Print to chat with color coding
   32     local color = "|cFF888888"
   32     if level == "ERROR" then
    8         color = "|cFFFF0000"
   24     elseif level == "WARN" then
    8         color = "|cFFFFFF00"
   16     elseif level == "INFO" then
    8         color = "|cFF00FF00"
          end
          
   32     print(color .. "[HealIQ] " .. logEntry .. "|r")
      end

   13 function HealIQ:LogError(message)
   13     self:DebugLog(message, "ERROR")
   13     if self.sessionStats then
****0         self.sessionStats.errorsLogged = self.sessionStats.errorsLogged + 1
          end
      end

   13 function HealIQ:GenerateDiagnosticDump()
    8     local dump = {}
          
          -- Header
    8     table.insert(dump, "=== HealIQ Diagnostic Dump ===")
    8     table.insert(dump, "Generated: " .. date("%Y-%m-%d %H:%M:%S"))
    8     table.insert(dump, "Version: " .. self.version)
    8     table.insert(dump, "")
          
          -- Session Statistics
    8     table.insert(dump, "=== Session Statistics ===")
    8     if self.sessionStats then
****0         if self.sessionStats.startTime then
****0             local sessionDuration = time() - self.sessionStats.startTime
****0             table.insert(dump, "Session Duration: " .. self:FormatDuration(sessionDuration))
              end
****0         table.insert(dump, "Suggestions Generated: " .. self.sessionStats.suggestions)
****0         table.insert(dump, "Rules Processed: " .. self.sessionStats.rulesProcessed)
****0         table.insert(dump, "Errors Logged: " .. self.sessionStats.errorsLogged)
****0         table.insert(dump, "Events Handled: " .. self.sessionStats.eventsHandled)
          else
    8         table.insert(dump, "Session statistics not yet initialized")
          end
    8     table.insert(dump, "")
          
          -- Configuration
    8     table.insert(dump, "=== Configuration ===")
    8     if self.db then
    8         table.insert(dump, "Enabled: " .. tostring(self.db.enabled))
    8         table.insert(dump, "Debug Mode: " .. tostring(self.debug))
          else
****0         table.insert(dump, "Database not yet initialized")
          end
    8     table.insert(dump, "")
          
          -- UI Configuration
    8     table.insert(dump, "=== UI Configuration ===")
    8     if self.db and self.db.ui then
    8         table.insert(dump, "Scale: " .. tostring(self.db.ui.scale))
    8         table.insert(dump, "Position: " .. self.db.ui.x .. ", " .. self.db.ui.y)
    8         table.insert(dump, "Locked: " .. tostring(self.db.ui.locked))
    8         table.insert(dump, "Show Queue: " .. tostring(self.db.ui.showQueue))
    8         table.insert(dump, "Queue Size: " .. tostring(self.db.ui.queueSize))
    8         table.insert(dump, "Queue Layout: " .. tostring(self.db.ui.queueLayout))
          else
****0         table.insert(dump, "UI configuration not yet initialized")
          end
    8     table.insert(dump, "")
          
          -- Rules Configuration
    8     table.insert(dump, "=== Rules Configuration ===")
    8     if self.db and self.db.rules then
  120         for rule, enabled in pairs(self.db.rules) do
  112             table.insert(dump, rule .. ": " .. tostring(enabled))
              end
          else
****0         table.insert(dump, "Rules configuration not yet initialized")
          end
    8     table.insert(dump, "")
          
          -- Current State
    8     table.insert(dump, "=== Current State ===")
    8     local _, class = UnitClass("player")
    8     local spec = GetSpecialization()
****0     table.insert(dump, "Class: " .. (class or "Unknown"))
****0     table.insert(dump, "Specialization: " .. (spec or "Unknown"))
****0     table.insert(dump, "In Combat: " .. tostring(InCombatLockdown()))
****0     table.insert(dump, "")
          
****0     return table.concat(dump, "\n")
      end


==============================================================================
Tests.lua
==============================================================================
      -- HealIQ Tests.lua
      -- Enhanced test infrastructure for HealIQ addon with WoW API mocking

   13 local _, HealIQ = ...

      -- Load WoW API Mock for testing
      local function loadWoWAPIMock()
          -- Try to load WoWAPIMock if available (for external testing)
    4     local success, WoWAPIMock = pcall(function()
   13         return dofile("WoWAPIMock.lua")
          end)
   13     if success then
    2         return WoWAPIMock
          else
              -- Return dummy mock for in-game environment
****0         return {
                  Install = function() end,
                  Reset = function() end,
                  SetGameState = function() end,
                  SetSpellCooldown = function() end,
                  SetUnitBuff = function() end,
****0             AddCombatLogEvent = function() end
   11         }
          end
      end

  864 local WoWAPIMock = loadWoWAPIMock()

  864 HealIQ.Tests = {}
  864 local Tests = HealIQ.Tests

      -- Test results storage
  864 local testResults = {}
    2 local totalTests = 0
  864 local passedTests = 0

      -- Test framework functions
    2 function Tests.Initialize()
  862     HealIQ:SafeCall(function()
              -- Install WoW API mocks for testing
****0         WoWAPIMock.Install()
   11         WoWAPIMock.Reset()
              
              -- Initialize test framework
   60         testResults = {}
   11         totalTests = 0
****0         passedTests = 0
   11         HealIQ:Print("Test framework initialized with WoW API mocking")
          end)
      end

   13 function Tests.Assert(condition, testName, errorMessage)
  242     totalTests = totalTests + 1
  253     local result = {
  661         name = testName,
  661         passed = condition,
  661         error = condition and nil or (errorMessage or "Assertion failed")
  419     }

  242     table.insert(testResults, result)

  253     if condition then
  253         passedTests = passedTests + 1
          end

  253     return condition
      end

    2 function Tests.AssertEqual(expected, actual, testName)
   14     local condition = expected == actual
   25     local errorMessage = string.format("Expected %s, got %s", tostring(expected), tostring(actual))
   24     return Tests.Assert(condition, testName, errorMessage)
      end

   10 function Tests.AssertNotNil(value, testName)
   47     local condition = value ~= nil
   41     local errorMessage = "Expected non-nil value"
   42     return Tests.Assert(condition, testName, errorMessage)
      end

    3 function Tests.AssertType(expectedType, value, testName)
  122     local actualType = type(value)
  133     local condition = actualType == expectedType
  123     local errorMessage = string.format("Expected type %s, got %s", expectedType, actualType)
  133     return Tests.Assert(condition, testName, errorMessage)
      end

      -- Run all tests
    4 function Tests.RunAll()
   13     HealIQ:Print("Running HealIQ tests...")

          -- Reset counters
   22     testResults = {}
   12     totalTests = 0
    3     passedTests = 0

          -- Run test suites
   23     Tests.TestCore()
   13     Tests.TestUI()
   14     Tests.TestConfig()
   12     Tests.TestTracker()
    2     Tests.TestLogging()
    3     Tests.TestDataStructures()

          -- Print results
   12     Tests.PrintResults()
      end

      -- Test Core functionality
    3 function Tests.TestCore()
          -- Test addon initialization
   12     Tests.AssertNotNil(HealIQ, "Core: HealIQ addon table exists")
   13     Tests.AssertNotNil(HealIQ.version, "Core: Version string exists")
    3     Tests.AssertType("string", HealIQ.version, "Core: Version is string")

          -- Test SafeCall function
   12     local testRan = false
   14     HealIQ:SafeCall(function()
    4         testRan = true
          end)
    2     Tests.Assert(testRan, "Core: SafeCall executes function")

          -- Test error handling in SafeCall
    2     local errorHandled = true
    4     HealIQ:SafeCall(function()
    3         error("Test error")
          end)
   12     Tests.Assert(errorHandled, "Core: SafeCall handles errors gracefully")

          -- Test version string format
   13     local versionPattern = "%d+%.%d+%.%d+"
    5     Tests.Assert(string.match(HealIQ.version, versionPattern) ~= nil,
    3         "Core: Version follows semantic versioning")

          -- Test debug flag
   12     Tests.AssertType("boolean", HealIQ.debug, "Core: Debug flag is boolean")

          -- Test database initialization function exists
    8     if HealIQ.InitializeDB then
    2         Tests.AssertType("function", HealIQ.InitializeDB, "Core: InitializeDB function exists")
          end

          -- Test message function exists
    3     if HealIQ.Message then
   10         Tests.AssertType("function", HealIQ.Message, "Core: Message function exists")
          end

          -- Test print function exists
   12     if HealIQ.Print then
   11         Tests.AssertType("function", HealIQ.Print, "Core: Print function exists")
          end

          -- Test SafeCall with return value
   12     local success, result = HealIQ:SafeCall(function()
   12         return 42
          end)
   10     Tests.Assert(success, "Core: SafeCall returns success status")
    3     Tests.AssertEqual(42, result, "Core: SafeCall returns function result")

          -- Test SafeCall with multiple return values (note: current implementation only returns first value)
   15     local success2, a = HealIQ:SafeCall(function()
    3         return "hello", "world"
          end)
    5     Tests.Assert(success2, "Core: SafeCall returns success for multiple values")
    5     Tests.AssertEqual("hello", a, "Core: SafeCall returns first value")

          -- Test CountSettings function
   12     if HealIQ.CountSettings then
    4         Tests.AssertType("function", HealIQ.CountSettings, "Core: CountSettings is function")
              
              -- Test with mock database
   26         local originalDB = HealIQ.db
   12         HealIQ.db = {
   18             enabled = true,
   10             debug = false,
    4             ui = {
    7                 scale = 1.0,
    4                 locked = false
   10             },
    2             rules = {
   10                 rejuvenation = true,
    4                 lifebloom = true
    3             }
   10         }
              
   11         local count = HealIQ:CountSettings()
   20         Tests.AssertType("number", count, "Core: CountSettings returns number")
   10         Tests.Assert(count > 0, "Core: CountSettings counts nested settings")
              
    3         HealIQ.db = originalDB -- Restore
          end

          -- Test OnVersionUpgrade function
   10     if HealIQ.OnVersionUpgrade then
   18         Tests.AssertType("function", HealIQ.OnVersionUpgrade, "Core: OnVersionUpgrade is function")
              
              -- Test version upgrade handling (just verify it executes without error)
    4         local upgradeSuccess = pcall(function()
    2             HealIQ:OnVersionUpgrade("0.0.1", "0.0.2")
   12             HealIQ:OnVersionUpgrade(nil, "0.0.25") -- First install case
              end)
   10         Tests.Assert(upgradeSuccess, "Core: OnVersionUpgrade executes without error")
          end

          -- Test database corruption handling simulation
    2     if HealIQ.InitializeDB then
              -- Save original global
   12         local originalHealIQDB = _G.HealIQDB
              
              -- Test with corrupted database (wrong type)
    4         _G.HealIQDB = "corrupted_string"
   14         local corruptSuccess = pcall(function()
   12             HealIQ:InitializeDB()
              end)
   10         Tests.Assert(corruptSuccess, "Core: InitializeDB handles corrupted database")
    5         Tests.AssertType("table", _G.HealIQDB, "Core: InitializeDB resets corrupted database to table")
              
              -- Test with nil database
   10         _G.HealIQDB = nil
   12         local nilSuccess = pcall(function()
    8             HealIQ:InitializeDB()
              end)
    6         Tests.Assert(nilSuccess, "Core: InitializeDB handles nil database")
    9         Tests.AssertType("table", _G.HealIQDB, "Core: InitializeDB creates database when nil")
              
              -- Test database structure after initialization
    2         if _G.HealIQDB then
    5             Tests.AssertType("table", _G.HealIQDB, "Core: Initialized database is table")
    6             Tests.AssertNotNil(_G.HealIQDB.enabled, "Core: Database has enabled field")
    5             Tests.AssertNotNil(_G.HealIQDB.ui, "Core: Database has ui section")
    9             Tests.AssertNotNil(_G.HealIQDB.rules, "Core: Database has rules section")
              end
              
              -- Restore original
   11         _G.HealIQDB = originalHealIQDB
          end

          -- Test InitializeSessionStats function (note: may be overridden by Logging.lua)
    7     if HealIQ.InitializeSessionStats then
    4         Tests.AssertType("function", HealIQ.InitializeSessionStats, "Core: InitializeSessionStats is function")
              
    8         local originalStats = HealIQ.sessionStats
              
              -- The Logging.lua version only sets startTime if sessionStats exists
              -- So we need to create a basic sessionStats first
    4         HealIQ.sessionStats = {
   10             suggestions = 0,
   11             rulesProcessed = 0,
   13             errorsLogged = 0,
   13             eventsHandled = 0
    6         }
              
    6         HealIQ:InitializeSessionStats()
              
              -- The function should ensure sessionStats exists and has startTime set
   10         Tests.AssertNotNil(HealIQ.sessionStats, "Core: InitializeSessionStats ensures sessionStats exists")
              
   11         if HealIQ.sessionStats then
    4             Tests.AssertType("table", HealIQ.sessionStats, "Core: sessionStats is table")
                  -- The Logging.lua version sets startTime
    7             if HealIQ.sessionStats.startTime then
   13                 Tests.AssertType("number", HealIQ.sessionStats.startTime, "Core: sessionStats has numeric startTime")
                  end
              end
              
    8         HealIQ.sessionStats = originalStats -- Restore
          end

          -- Test Print function behavior
    8     if HealIQ.Print then
    8         local originalDebug = HealIQ.debug
              
              -- Test with debug enabled
    4         HealIQ.debug = true
   11         local debugSuccess = pcall(function()
    7             HealIQ:Print("Test message")
              end)
    6         Tests.Assert(debugSuccess, "Core: Print executes without error when debug enabled")
              
              -- Test with debug disabled
    2         HealIQ.debug = false
    6         local noDebugSuccess = pcall(function()
    9             HealIQ:Print("Test message")
              end)
    2         Tests.Assert(noDebugSuccess, "Core: Print executes without error when debug disabled")
              
    9         HealIQ.debug = originalDebug -- Restore
          end
      end

      -- Test UI functionality
   11 function Tests.TestUI()
    4     Tests.AssertNotNil(HealIQ.UI, "UI: UI module exists")

          -- Test UI initialization without errors
    8     if HealIQ.db and HealIQ.db.ui then
    3         local initialScale = HealIQ.db.ui.scale
    5         Tests.AssertType("number", initialScale, "UI: Scale is numeric")
   10         Tests.Assert(initialScale > 0, "UI: Scale is positive")

              -- Test frame info retrieval
    6         local frameInfo = HealIQ.UI:GetFrameInfo()
   10         if frameInfo then
    2             Tests.AssertType("table", frameInfo, "UI: Frame info returns table")
    7             Tests.AssertType("number", frameInfo.scale, "UI: Frame scale is numeric")
              end
          end

          -- Test basic UI functions exist
    5     if HealIQ.UI.Initialize then
    5         Tests.AssertType("function", HealIQ.UI.Initialize, "UI: Initialize function exists")
          end

    7     if HealIQ.UI.SetEnabled then
    3         Tests.AssertType("function", HealIQ.UI.SetEnabled, "UI: SetEnabled function exists")
          end

    9     if HealIQ.UI.SetScale then
    8         Tests.AssertType("function", HealIQ.UI.SetScale, "UI: SetScale function exists")
              
              -- Test SetScale with valid values
    7         if HealIQ.db and HealIQ.db.ui then
   10             local originalScale = HealIQ.db.ui.scale
                  
                  -- Test valid scale values
   10             HealIQ.UI:SetScale(1.0)
    4             Tests.AssertEqual(1.0, HealIQ.db.ui.scale, "UI: SetScale sets valid scale 1.0")
                  
   16             HealIQ.UI:SetScale(1.5)
   13             Tests.AssertEqual(1.5, HealIQ.db.ui.scale, "UI: SetScale sets valid scale 1.5")
                  
    8             HealIQ.UI:SetScale(0.8)
    6             Tests.AssertEqual(0.8, HealIQ.db.ui.scale, "UI: SetScale sets valid scale 0.8")
                  
                  -- Restore original
    8             HealIQ.db.ui.scale = originalScale
              end
          end

    3     if HealIQ.UI.ResetPosition then
    7         Tests.AssertType("function", HealIQ.UI.ResetPosition, "UI: ResetPosition function exists")
              
              -- Test ResetPosition functionality
    3         if HealIQ.db and HealIQ.db.ui then
    8             local originalX = HealIQ.db.ui.x
   11             local originalY = HealIQ.db.ui.y
                  
                  -- Change position
    8             HealIQ.db.ui.x = 100
    3             HealIQ.db.ui.y = 200
                  
                  -- Reset position
    3             HealIQ.UI:ResetPosition()
                  
                  -- Verify it changed (exact values depend on implementation)
    7             Tests.Assert(HealIQ.db.ui.x ~= 100 or HealIQ.db.ui.y ~= 200,
    7                 "UI: ResetPosition changes position values")
                  
                  -- Restore (or leave as reset, which is fine)
              end
          end

    2     if HealIQ.UI.ToggleOptionsFrame then
    8         Tests.AssertType("function", HealIQ.UI.ToggleOptionsFrame,
    6             "UI: ToggleOptionsFrame function exists")
          end

          -- Test UI setter functions
    4     if HealIQ.UI.SetShowSpellName then
    6         Tests.AssertType("function", HealIQ.UI.SetShowSpellName, "UI: SetShowSpellName function exists")
              
    6         if HealIQ.db and HealIQ.db.ui then
    6             local original = HealIQ.db.ui.showSpellName
                  
    6             HealIQ.UI:SetShowSpellName(true)
    3             Tests.Assert(HealIQ.db.ui.showSpellName == true, "UI: SetShowSpellName sets true")
                  
    5             HealIQ.UI:SetShowSpellName(false)
    4             Tests.Assert(HealIQ.db.ui.showSpellName == false, "UI: SetShowSpellName sets false")
                  
    4             HealIQ.db.ui.showSpellName = original -- Restore
              end
          end

   11     if HealIQ.UI.SetShowCooldown then
   11         Tests.AssertType("function", HealIQ.UI.SetShowCooldown, "UI: SetShowCooldown function exists")
              
    3         if HealIQ.db and HealIQ.db.ui then
    5             local original = HealIQ.db.ui.showCooldown
                  
    7             HealIQ.UI:SetShowCooldown(true)
    3             Tests.Assert(HealIQ.db.ui.showCooldown == true, "UI: SetShowCooldown sets true")
                  
    7             HealIQ.UI:SetShowCooldown(false)
    5             Tests.Assert(HealIQ.db.ui.showCooldown == false, "UI: SetShowCooldown sets false")
                  
    6             HealIQ.db.ui.showCooldown = original -- Restore
              end
          end

          -- Test UI constants if they exist
    6     if HealIQ.UI.OPTIONS_FRAME_HEIGHT then
    5         Tests.AssertType("number", HealIQ.UI.OPTIONS_FRAME_HEIGHT,
****0             "UI: OPTIONS_FRAME_HEIGHT is number")
    1         Tests.Assert(HealIQ.UI.OPTIONS_FRAME_HEIGHT > 0, "UI: OPTIONS_FRAME_HEIGHT is positive")
          end

          -- Test position and scale validation
    8     if HealIQ.db and HealIQ.db.ui then
              -- Test scale bounds
    6         if HealIQ.db.ui.scale then
    4             Tests.Assert(HealIQ.db.ui.scale >= 0.5 and HealIQ.db.ui.scale <= 2.0,
   10                 "UI: Scale within valid bounds")
              end

              -- Test boolean flags
    2         if HealIQ.db.ui.locked ~= nil then
    4             Tests.AssertType("boolean", HealIQ.db.ui.locked, "UI: Locked is boolean")
              end
    5         if HealIQ.db.ui.showIcon ~= nil then
    4             Tests.AssertType("boolean", HealIQ.db.ui.showIcon, "UI: ShowIcon is boolean")
              end
   10         if HealIQ.db.ui.showSpellName ~= nil then
    6             Tests.AssertType("boolean", HealIQ.db.ui.showSpellName, "UI: ShowSpellName is boolean")
              end
   13         if HealIQ.db.ui.showCooldown ~= nil then
    9             Tests.AssertType("boolean", HealIQ.db.ui.showCooldown, "UI: ShowCooldown is boolean")
              end
    6         if HealIQ.db.ui.showQueue ~= nil then
    9             Tests.AssertType("boolean", HealIQ.db.ui.showQueue, "UI: ShowQueue is boolean")
              end
          end

          -- Test GetFrameInfo function
   10     if HealIQ.UI.GetFrameInfo then
    5         Tests.AssertType("function", HealIQ.UI.GetFrameInfo, "UI: GetFrameInfo is function")
              
   10         local frameInfo = HealIQ.UI:GetFrameInfo()
              -- frameInfo might be nil if no frame exists yet, which is valid
    8         if frameInfo then
    3             Tests.AssertType("table", frameInfo, "UI: GetFrameInfo returns table when frame exists")
    2             Tests.AssertType("number", frameInfo.scale, "UI: FrameInfo contains numeric scale")
    7             Tests.AssertType("boolean", frameInfo.shown, "UI: FrameInfo contains boolean shown")
    5             Tests.AssertType("boolean", frameInfo.locked, "UI: FrameInfo contains boolean locked")
              end
          end

          -- Test RecreateFrames function
    8     if HealIQ.UI.RecreateFrames then
   12         Tests.AssertType("function", HealIQ.UI.RecreateFrames, "UI: RecreateFrames is function")
              
              -- Test that it executes without error (may require WoW API)
   12         local success = pcall(function()
    8             HealIQ.UI:RecreateFrames()
              end)
              -- In test environment without WoW API, this may fail, which is acceptable
    4         Tests.Assert(true, "UI: RecreateFrames function exists (may require WoW API in test env)")
          end

          -- Test UpdateOptionsFrame function
    3     if HealIQ.UI.UpdateOptionsFrame then
    2         Tests.AssertType("function", HealIQ.UI.UpdateOptionsFrame, "UI: UpdateOptionsFrame is function")
              
    8         local success = pcall(function()
    9             HealIQ.UI:UpdateOptionsFrame()
              end)
    5         Tests.Assert(success, "UI: UpdateOptionsFrame executes without error")
          end

          -- Test SetEnabled function behavior (UI visibility, not database state)
    6     if HealIQ.UI.SetEnabled then
    7         Tests.AssertType("function", HealIQ.UI.SetEnabled, "UI: SetEnabled function exists")
              
              -- Test that it executes without error (controls UI visibility, not db.enabled)
    4         local success1 = pcall(function()
   11             HealIQ.UI:SetEnabled(true)
              end)
    6         local success2 = pcall(function()
    2             HealIQ.UI:SetEnabled(false)
              end)
    5         Tests.Assert(success1 and success2, "UI: SetEnabled executes without error for both states")
          end
      end

      -- Test Config functionality
    2 function Tests.TestConfig()
    2     Tests.AssertNotNil(HealIQ.Config, "Config: Config module exists")

          -- Test command registration (only test if SLASH_HEALIQ1 is available)
    5     if _G.SLASH_HEALIQ1 then
    2         Tests.AssertNotNil(_G.SLASH_HEALIQ1, "Config: Primary slash command registered")
    2         Tests.AssertEqual("/healiq", _G.SLASH_HEALIQ1, "Config: Primary slash command correct")
          end

          -- Test option get/set if database is available
    2     if HealIQ.db then
    2         local originalDebug = HealIQ.db.debug
    5         HealIQ.Config:SetOption("general", "debug", true)
    8         local newDebug = HealIQ.Config:GetOption("general", "debug")
    5         Tests.Assert(newDebug == true, "Config: Can set and get debug option")

              -- Restore original value
    5         HealIQ.Config:SetOption("general", "debug", originalDebug)
          end

          -- Test command functions exist
    4     if HealIQ.Config.commands then
    5         Tests.AssertType("table", HealIQ.Config.commands, "Config: Commands table exists")
              
    5         if HealIQ.Config.commands.version then
    4             Tests.AssertType("function", HealIQ.Config.commands.version,
    2                 "Config: Version command is function")
              end
              
    5         if HealIQ.Config.commands.enable then
    5             Tests.AssertType("function", HealIQ.Config.commands.enable,
    2                 "Config: Enable command is function")
              end
              
    6         if HealIQ.Config.commands.disable then
    4             Tests.AssertType("function", HealIQ.Config.commands.disable,
    5                 "Config: Disable command is function")
              end
              
    5         if HealIQ.Config.commands.toggle then
    7             Tests.AssertType("function", HealIQ.Config.commands.toggle,
    5                 "Config: Toggle command is function")
              end
              
    2         if HealIQ.Config.commands.help then
    7             Tests.AssertType("function", HealIQ.Config.commands.help,
    5                 "Config: Help command is function")
              end
              
    5         if HealIQ.Config.commands.config then
    7             Tests.AssertType("function", HealIQ.Config.commands.config,
    4                 "Config: Config command is function")
              end
              
    5         if HealIQ.Config.commands.ui then
    7             Tests.AssertType("function", HealIQ.Config.commands.ui,
    5                 "Config: UI command is function")
              end
          end

          -- Test command execution with database setup
    6     if HealIQ.db and HealIQ.Config.commands then
              -- Test enable command
    4         if HealIQ.Config.commands.enable then
    6             local originalEnabled = HealIQ.db.enabled
   12             HealIQ.db.enabled = false
    7             HealIQ.Config.commands.enable()
    2             Tests.Assert(HealIQ.db.enabled == true, "Config: Enable command sets enabled to true")
    3             HealIQ.db.enabled = originalEnabled -- Restore
              end
              
              -- Test disable command
    7         if HealIQ.Config.commands.disable then
    6             local originalEnabled = HealIQ.db.enabled
    7             HealIQ.db.enabled = true
    6             HealIQ.Config.commands.disable()
    6             Tests.Assert(HealIQ.db.enabled == false, "Config: Disable command sets enabled to false")
    2             HealIQ.db.enabled = originalEnabled -- Restore
              end
              
              -- Test toggle command
    2         if HealIQ.Config.commands.toggle then
    2             local originalEnabled = HealIQ.db.enabled
    6             local initialState = HealIQ.db.enabled
    2             HealIQ.Config.commands.toggle()
    5             Tests.Assert(HealIQ.db.enabled == (not initialState), "Config: Toggle command changes enabled state")
    6             HealIQ.db.enabled = originalEnabled -- Restore
              end
          end

          -- Test command argument parsing
    7     if HealIQ.Config.HandleSlashCommand then
    4         Tests.AssertType("function", HealIQ.Config.HandleSlashCommand,
    5             "Config: HandleSlashCommand is function")
          end

          -- Test option validation with different types
    4     if HealIQ.Config.SetOption and HealIQ.db then
              -- Test setting valid options
    4         local originalScale = HealIQ.db.ui and HealIQ.db.ui.scale
    5         if originalScale then
    3             HealIQ.Config:SetOption("ui", "scale", 1.5)
    6             local newScale = HealIQ.Config:GetOption("ui", "scale")
    5             Tests.AssertEqual(1.5, newScale, "Config: Can set numeric option")
                  -- Restore
    5             HealIQ.Config:SetOption("ui", "scale", originalScale)
              end
          end

          -- Test additional command functions for better coverage
    5     if HealIQ.Config.commands then
              -- Test version command
    6         if HealIQ.Config.commands.version then
    4             local success = pcall(function()
    3                 HealIQ.Config.commands.version()
                  end)
    3             Tests.Assert(success, "Config: Version command executes without error")
              end
              
              -- Test help command
    3         if HealIQ.Config.commands.help then
    6             local success = pcall(function()
    5                 HealIQ.Config.commands.help()
                  end)
    3             Tests.Assert(success, "Config: Help command executes without error")
              end
              
              -- Test config command (opens options)
    4         if HealIQ.Config.commands.config then
   10             local success = pcall(function()
    7                 HealIQ.Config.commands.config()
                  end)
    3             Tests.Assert(success, "Config: Config command executes without error")
              end
              
              -- Test status command (may use WoW API)
    5         if HealIQ.Config.commands.status then
    7             local success = pcall(function()
    6                 HealIQ.Config.commands.status()
                  end)
                  -- In test environment, this may fail due to WoW API calls, which is acceptable
    6             Tests.Assert(true, "Config: Status command exists (may require WoW API)")
              end
          end

          -- Test UI command functions
    9     if HealIQ.db and HealIQ.db.ui and HealIQ.Config.commands and HealIQ.Config.commands.ui then
              -- Test UI lock/unlock
    6         local originalLocked = HealIQ.db.ui.locked
    7         HealIQ.Config.commands.ui("lock")
    8         Tests.Assert(HealIQ.db.ui.locked == true, "Config: UI lock command works")
    7         HealIQ.Config.commands.ui("unlock")
    4         Tests.Assert(HealIQ.db.ui.locked == false, "Config: UI unlock command works")
    5         HealIQ.db.ui.locked = originalLocked -- Restore
              
              -- Test queue size validation (may trigger UI recreation, use pcall)
    9         local originalQueueSize = HealIQ.db.ui.queueSize
    8         local success1 = pcall(function()
    8             HealIQ.Config.commands.ui("queuesize", "3")
              end)
    7         if success1 then
    3             Tests.AssertEqual(3, HealIQ.db.ui.queueSize, "Config: UI queuesize command sets valid size")
              end
    9         HealIQ.db.ui.queueSize = originalQueueSize -- Restore
              
              -- Test layout setting (may trigger UI recreation, use pcall)
    4         local originalLayout = HealIQ.db.ui.queueLayout
   11         local success2 = pcall(function()
    5             HealIQ.Config.commands.ui("layout", "vertical")
              end)
    5         if success2 then
    7             Tests.AssertEqual("vertical", HealIQ.db.ui.queueLayout, "Config: UI layout command sets layout")
              end
    4         HealIQ.db.ui.queueLayout = originalLayout -- Restore
          end
      end

      -- Test Tracker functionality
    3 function Tests.TestTracker()
    9     if HealIQ.Tracker then
    7         Tests.AssertNotNil(HealIQ.Tracker, "Tracker: Tracker module exists")

              -- Test basic tracker functions
    6         Tests.AssertType("function", HealIQ.Tracker.Initialize, "Tracker: Initialize function exists")

              -- Test spell tracking if available
    4         if HealIQ.Tracker.IsSpellKnown then
    3             local result = HealIQ.Tracker:IsSpellKnown("Rejuvenation")
    4             Tests.AssertType("boolean", result, "Tracker: IsSpellKnown returns boolean")
              end

              -- Test spell ID constants exist
    8         if HealIQ.Tracker.SPELLS then
    5             Tests.AssertType("table", HealIQ.Tracker.SPELLS, "Tracker: SPELLS table exists")
                  -- Test some common spells
    4             if HealIQ.Tracker.SPELLS.REJUVENATION then
    3                 Tests.AssertType("number", HealIQ.Tracker.SPELLS.REJUVENATION,
    3                     "Tracker: Rejuvenation spell ID is number")
                  end
    2             if HealIQ.Tracker.SPELLS.LIFEBLOOM then
    5                 Tests.AssertType("number", HealIQ.Tracker.SPELLS.LIFEBLOOM,
    2                     "Tracker: Lifebloom spell ID is number")
                  end
              end

              -- Test spell book scanning functions if available
    6         if HealIQ.Tracker.ScanSpellbook then
    1             Tests.AssertType("function", HealIQ.Tracker.ScanSpellbook,
    2                 "Tracker: ScanSpellbook is function")
              end

              -- Test event registration functions
    6         if HealIQ.Tracker.RegisterEvents then
   10             Tests.AssertType("function", HealIQ.Tracker.RegisterEvents,
    7                 "Tracker: RegisterEvents is function")
              end
          end
      end

      -- Test Logging functionality
    4 function Tests.TestLogging()
    5     if HealIQ.Logging then
    4         Tests.AssertNotNil(HealIQ.Logging, "Logging: Logging module exists")

              -- Test InitializeVariables function
    6         if HealIQ.Logging.InitializeVariables then
   12             Tests.AssertType("function", HealIQ.Logging.InitializeVariables,
    7                 "Logging: InitializeVariables is function")

                  -- Test that it initializes session stats
    7             local oldStats = HealIQ.sessionStats
    5             HealIQ.sessionStats = nil
    6             HealIQ.Logging:InitializeVariables()
    4             Tests.AssertNotNil(HealIQ.sessionStats, "Logging: InitializeVariables creates sessionStats")
    6             Tests.AssertType("table", HealIQ.sessionStats, "Logging: sessionStats is table")

                  -- Test session stats structure
    3             if HealIQ.sessionStats then
    7                 Tests.AssertNotNil(HealIQ.sessionStats.suggestions,
    8                     "Logging: sessionStats has suggestions field")
    8                 Tests.AssertNotNil(HealIQ.sessionStats.rulesProcessed,
    5                     "Logging: sessionStats has rulesProcessed field")
    6                 Tests.AssertNotNil(HealIQ.sessionStats.errorsLogged,
    6                     "Logging: sessionStats has errorsLogged field")
    6                 Tests.AssertType("number", HealIQ.sessionStats.suggestions,
    3                     "Logging: suggestions is number")
    5                 Tests.AssertType("number", HealIQ.sessionStats.rulesProcessed,
    5                     "Logging: rulesProcessed is number")
                  end

                  -- Restore old stats
    4             HealIQ.sessionStats = oldStats
              end

              -- Test DebugLog function exists and behavior
    4         if HealIQ.DebugLog then
    5             Tests.AssertType("function", HealIQ.DebugLog, "Logging: DebugLog is function")
                  
                  -- Test debug logging with debug enabled
    3             local originalDebug = HealIQ.debug
    2             HealIQ.debug = true
                  
                  -- This should execute without error (we can't easily test print output)
    5             local success = pcall(function()
    4                 HealIQ:DebugLog("Test message")
    5                 HealIQ:DebugLog("Test error message", "ERROR")
    5                 HealIQ:DebugLog("Test warning message", "WARN")
    5                 HealIQ:DebugLog("Test info message", "INFO")
                  end)
    6             Tests.Assert(success, "Logging: DebugLog executes without error")
                  
    7             HealIQ.debug = originalDebug -- Restore
              end

              -- Test LogError function
    7         if HealIQ.LogError then
    5             Tests.AssertType("function", HealIQ.LogError, "Logging: LogError is function")
                  
                  -- Test error logging increments counter
  107             if HealIQ.sessionStats then
    7                 local originalErrors = HealIQ.sessionStats.errorsLogged
    2                 HealIQ:LogError("Test error")
    4                 Tests.Assert(HealIQ.sessionStats.errorsLogged == originalErrors + 1,
    4                     "Logging: LogError increments error counter")
                  end
              end

              -- Test InitializeSessionStats function exists
  108         if HealIQ.InitializeSessionStats then
    8             Tests.AssertType("function", HealIQ.InitializeSessionStats,
    4                 "Logging: InitializeSessionStats is function")
                  
                  -- Test that it sets start time
    5             local oldStats = HealIQ.sessionStats
    6             HealIQ.sessionStats = {
    5                 suggestions = 0,
    4                 rulesProcessed = 0,
    5                 errorsLogged = 0,
    3                 eventsHandled = 0
  120             }
                  
    2             HealIQ:InitializeSessionStats()
    3             Tests.AssertNotNil(HealIQ.sessionStats.startTime, "Logging: InitializeSessionStats sets startTime")
    5             Tests.AssertType("number", HealIQ.sessionStats.startTime, "Logging: startTime is number")
                  
    4             HealIQ.sessionStats = oldStats -- Restore
              end

              -- Test diagnostic dump generation
    3         if HealIQ.GenerateDiagnosticDump then
    7             Tests.AssertType("function", HealIQ.GenerateDiagnosticDump,
    3                 "Logging: GenerateDiagnosticDump is function")
                  
                  -- Use pcall since it may use WoW API functions not available in test environment
    5             local success, dump = pcall(function()
    5                 return HealIQ:GenerateDiagnosticDump()
                  end)
                  
    3             if success then
    2                 Tests.AssertType("string", dump, "Logging: GenerateDiagnosticDump returns string")
****0                 Tests.Assert(string.len(dump) > 0, "Logging: Diagnostic dump is not empty")
****0                 Tests.Assert(string.find(dump, "HealIQ Diagnostic Dump") ~= nil,
    1                     "Logging: Diagnostic dump contains header")
    2                 Tests.Assert(string.find(dump, "Version: " .. HealIQ.version) ~= nil,
    1                     "Logging: Diagnostic dump contains version")
                  else
                      -- Function exists but requires WoW API, which is acceptable
    2                 Tests.Assert(true, "Logging: GenerateDiagnosticDump requires WoW API (expected in test env)")
                  end
              end

              -- Test FormatDuration function if it exists
    2         if HealIQ.FormatDuration then
    2             Tests.AssertType("function", HealIQ.FormatDuration, "Logging: FormatDuration is function")
                  
                  -- Test various duration formats
  123             local duration1 = HealIQ:FormatDuration(65)  -- 1 minute 5 seconds
    2             Tests.AssertType("string", duration1, "Logging: FormatDuration returns string for 65 seconds")
                  
    2             local duration2 = HealIQ:FormatDuration(3661)  -- 1 hour 1 minute 1 second
    3             Tests.AssertType("string", duration2, "Logging: FormatDuration returns string for 3661 seconds")
                  
    2             local duration3 = HealIQ:FormatDuration(30)  -- 30 seconds
    3             Tests.AssertType("string", duration3, "Logging: FormatDuration returns string for 30 seconds")
              end
          end
      end

      -- Print test results
    4 function Tests.PrintResults()
    3     print("|cFF00FF00=== HealIQ Test Results ===|r")
    6     print(string.format("Total Tests: %d", totalTests))
    3     print(string.format("Passed: |cFF00FF00%d|r", passedTests))
    5     print(string.format("Failed: |cFFFF0000%d|r", totalTests - passedTests))

    3     if totalTests > 0 then
    5         local successRate = (passedTests / totalTests) * 100
    5         print(string.format("Success Rate: %.1f%%", successRate))
          end

          -- Show failed tests
    4     local failedTests = {}
  246     for _, result in ipairs(testResults) do
  243         if not result.passed then
    1             table.insert(failedTests, result)
              end
          end

    4     if #failedTests > 0 then
    2         print("|cFFFF0000Failed Tests:|r")
    3         for _, result in ipairs(failedTests) do
    2             print(string.format("  - %s: %s", result.name, result.error))
              end
          else
    4         print("|cFF00FF00All tests passed!|r")
          end

    3     print("|cFF00FF00========================|r")
      end

      -- Quick validation tests for critical functionality
    3 function Tests.RunQuickValidation()
****0     local errors = {}

          -- Check critical modules exist
    1     if not HealIQ then
    1         table.insert(errors, "Core HealIQ addon not loaded")
          end

    2     if not HealIQ.UI then
****0         table.insert(errors, "UI module not available")
          end

****0     if not HealIQ.Config then
****0         table.insert(errors, "Config module not available")
          end

          -- Check database initialization
    1     if not HealIQ.db then
****0         table.insert(errors, "Database not initialized")
    4     elseif not HealIQ.db.ui then
    1         table.insert(errors, "UI database not initialized")
          end

          -- Check slash commands (only if available)
    1     if _G.SLASH_HEALIQ1 and not _G.SLASH_HEALIQ1 then
    1         table.insert(errors, "Slash commands not registered")
          end

****0     if #errors > 0 then
    2         print("|cFFFF0000HealIQ Validation Errors:|r")
    1         for _, error in ipairs(errors) do
****0             print("  - " .. error)
              end
    1         return false
          else
    1         print("|cFF00FF00HealIQ validation passed - addon appears to be working correctly|r")
    1         return true
          end
      end

      -- Test data structure validation
    3 function Tests.TestDataStructures()
          -- Test that HealIQ table exists and has expected structure
    2     Tests.AssertNotNil(HealIQ, "DataStructures: HealIQ main table exists")

          -- Test version info
    3     if HealIQ.version then
    3         Tests.AssertType("string", HealIQ.version, "DataStructures: Version is string")
              -- Test version format (major.minor.patch)
    2         local major, minor, patch = string.match(HealIQ.version, "^(%d+)%.(%d+)%.(%d+)$")
    2         Tests.AssertNotNil(major, "DataStructures: Version has major number")
    2         Tests.AssertNotNil(minor, "DataStructures: Version has minor number")
    3         Tests.AssertNotNil(patch, "DataStructures: Version has patch number")
          end

          -- Test database structure if available
    2     if HealIQ.db then
    2         Tests.AssertType("table", HealIQ.db, "DataStructures: Database is table")

              -- Test UI settings structure
    2         if HealIQ.db.ui then
    2             Tests.AssertType("table", HealIQ.db.ui, "DataStructures: UI settings is table")
    2             if HealIQ.db.ui.scale then
    4                 Tests.AssertType("number", HealIQ.db.ui.scale, "DataStructures: UI scale is number")
                  end
              end

              -- Test rules settings structure
    2         if HealIQ.db.rules then
    2             Tests.AssertType("table", HealIQ.db.rules, "DataStructures: Rules settings is table")
              end

              -- Test strategy settings structure
    2         if HealIQ.db.strategy then
    2             Tests.AssertType("table", HealIQ.db.strategy, "DataStructures: Strategy settings is table")
              end
          end

          -- Test session stats structure
    2     if HealIQ.sessionStats then
****0         Tests.AssertType("table", HealIQ.sessionStats, "DataStructures: Session stats is table")

****0         local expectedFields = {"suggestions", "rulesProcessed", "errorsLogged", "eventsHandled"}
****0         for _, field in ipairs(expectedFields) do
****0             if HealIQ.sessionStats[field] ~= nil then
****0                 Tests.AssertType("number", HealIQ.sessionStats[field],
****0                     "DataStructures: " .. field .. " is number")
                  end
              end
          end
      end

      -- Enhanced tests with WoW API mocking for better coverage
    2 function Tests.RunMockedEngineTests()
****0     HealIQ:Print("Running enhanced Engine tests with WoW API mocking...")
          
****0     if not HealIQ.Engine then
****0         Tests.Assert(false, "Engine: Module not loaded")
****0         return
          end
          
          -- Test Engine initialization
****0     Tests.AssertType("table", HealIQ.Engine, "Engine: Engine module is table")
          
          -- Test GetSuggestion function with mocked game state
****0     if HealIQ.Engine.GetSuggestion then
****0         Tests.AssertType("function", HealIQ.Engine.GetSuggestion, "Engine: GetSuggestion is function")
              
              -- Test with different health scenarios
****0         WoWAPIMock.SetGameState({
                  targetExists = true,
                  targetHealth = 0.3, -- Low health
****0             targetMaxHealth = 10000
              })
              
****0         local success, suggestion = pcall(function()
****0             return HealIQ.Engine:GetSuggestion()
              end)
              
****0         if success and suggestion then
****0             Tests.AssertType("table", suggestion, "Engine: GetSuggestion returns table")
****0             if suggestion.spellId then
****0                 Tests.AssertType("number", suggestion.spellId, "Engine: Suggestion has spellId")
                  end
****0             if suggestion.targetType then
****0                 Tests.AssertType("string", suggestion.targetType, "Engine: Suggestion has targetType")
                  end
              else
****0             Tests.Assert(true, "Engine: GetSuggestion requires full WoW environment")
              end
          end
          
          -- Test GetTargetHealth function
****0     if HealIQ.Engine.GetTargetHealth then
****0         Tests.AssertType("function", HealIQ.Engine.GetTargetHealth, "Engine: GetTargetHealth is function")
              
****0         local success, health, maxHealth = pcall(function()
****0             return HealIQ.Engine:GetTargetHealth("target")
              end)
              
****0         if success then
****0             Tests.AssertType("number", health, "Engine: GetTargetHealth returns health number")
****0             Tests.AssertType("number", maxHealth, "Engine: GetTargetHealth returns maxHealth number")
****0             Tests.Assert(health <= maxHealth, "Engine: Health <= maxHealth")
              end
          end
          
          -- Test spell cooldown checking
****0     if HealIQ.Engine.IsSpellOnCooldown then
****0         Tests.AssertType("function", HealIQ.Engine.IsSpellOnCooldown, "Engine: IsSpellOnCooldown is function")
              
              -- Set up mock cooldown
****0         WoWAPIMock.SetSpellCooldown(774, GetTime(), 1.5) -- Rejuvenation on cooldown
              
****0         local success, onCooldown = pcall(function()
****0             return HealIQ.Engine:IsSpellOnCooldown(774)
              end)
              
****0         if success then
****0             Tests.AssertType("boolean", onCooldown, "Engine: IsSpellOnCooldown returns boolean")
              end
          end
          
          -- Test priority calculation
****0     if HealIQ.Engine.CalculatePriority then
****0         Tests.AssertType("function", HealIQ.Engine.CalculatePriority, "Engine: CalculatePriority is function")
              
****0         local success, priority = pcall(function()
****0             return HealIQ.Engine:CalculatePriority("target", 0.3)
              end)
              
****0         if success and priority then
****0             Tests.AssertType("number", priority, "Engine: CalculatePriority returns number")
****0             Tests.Assert(priority >= 0, "Engine: Priority is non-negative")
              end
          end
      end

    2 function Tests.RunMockedUITests()
****0     HealIQ:Print("Running enhanced UI tests with WoW API mocking...")
          
****0     if not HealIQ.UI then
****0         Tests.Assert(false, "UI: Module not loaded")
****0         return
          end
          
****0     Tests.AssertType("table", HealIQ.UI, "UI: UI module is table")
          
          -- Test frame creation functions
****0     if HealIQ.UI.CreateMainFrame then
****0         Tests.AssertType("function", HealIQ.UI.CreateMainFrame, "UI: CreateMainFrame is function")
              
****0         local success = pcall(function()
****0             HealIQ.UI:CreateMainFrame()
              end)
****0         Tests.Assert(success, "UI: CreateMainFrame executes without error")
          end
          
****0     if HealIQ.UI.CreateMinimapButton then
****0         Tests.AssertType("function", HealIQ.UI.CreateMinimapButton, "UI: CreateMinimapButton is function")
              
****0         local success = pcall(function()
****0             HealIQ.UI:CreateMinimapButton()
              end)
****0         Tests.Assert(success, "UI: CreateMinimapButton executes without error")
          end
          
****0     if HealIQ.UI.CreateOptionsFrame then
****0         Tests.AssertType("function", HealIQ.UI.CreateOptionsFrame, "UI: CreateOptionsFrame is function")
              
****0         local success = pcall(function()
****0             HealIQ.UI:CreateOptionsFrame()
              end)
****0         Tests.Assert(success, "UI: CreateOptionsFrame executes without error")
          end
          
          -- Test utility functions that don't require complex UI state
****0     if HealIQ.UI.SetScale then
****0         Tests.AssertType("function", HealIQ.UI.SetScale, "UI: SetScale is function")
              
****0         local success = pcall(function()
****0             HealIQ.UI:SetScale(1.0)
****0             HealIQ.UI:SetScale(0.5)
****0             HealIQ.UI:SetScale(2.0)
              end)
****0         Tests.Assert(success, "UI: SetScale handles different values")
          end
          
****0     if HealIQ.UI.GetScale then
****0         Tests.AssertType("function", HealIQ.UI.GetScale, "UI: GetScale is function")
              
****0         local success, scale = pcall(function()
****0             return HealIQ.UI:GetScale()
              end)
              
****0         if success and scale then
****0             Tests.AssertType("number", scale, "UI: GetScale returns number")
****0             Tests.Assert(scale > 0, "UI: Scale is positive")
              end
          end
          
          -- Test Show/Hide functions
****0     if HealIQ.UI.Show then
****0         Tests.AssertType("function", HealIQ.UI.Show, "UI: Show is function")
              
****0         local success = pcall(function()
****0             HealIQ.UI:Show()
              end)
****0         Tests.Assert(success, "UI: Show executes without error")
          end
          
****0     if HealIQ.UI.Hide then
****0         Tests.AssertType("function", HealIQ.UI.Hide, "UI: Hide is function")
              
****0         local success = pcall(function()
****0             HealIQ.UI:Hide()
              end)
****0         Tests.Assert(success, "UI: Hide executes without error")
          end
          
          -- Test positioning functions
****0     if HealIQ.UI.SetPosition then
****0         Tests.AssertType("function", HealIQ.UI.SetPosition, "UI: SetPosition is function")
              
****0         local success = pcall(function()
****0             HealIQ.UI:SetPosition(100, 200)
****0             HealIQ.UI:SetPosition(0, 0)
****0             HealIQ.UI:SetPosition(-100, -200)
              end)
****0         Tests.Assert(success, "UI: SetPosition handles different coordinates")
          end
          
****0     if HealIQ.UI.GetPosition then
****0         Tests.AssertType("function", HealIQ.UI.GetPosition, "UI: GetPosition is function")
              
****0         local success, x, y = pcall(function()
****0             return HealIQ.UI:GetPosition()
              end)
              
****0         if success and x and y then
****0             Tests.AssertType("number", x, "UI: GetPosition returns x coordinate")
****0             Tests.AssertType("number", y, "UI: GetPosition returns y coordinate")
              end
          end
      end

    2 function Tests.RunMockedTrackerTests()
****0     HealIQ:Print("Running enhanced Tracker tests with WoW API mocking...")
          
****0     if not HealIQ.Tracker then
****0         Tests.Assert(false, "Tracker: Module not loaded")
****0         return
          end
          
****0     Tests.AssertType("table", HealIQ.Tracker, "Tracker: Tracker module is table")
          
          -- Test buff tracking functions
****0     if HealIQ.Tracker.HasBuff then
****0         Tests.AssertType("function", HealIQ.Tracker.HasBuff, "Tracker: HasBuff is function")
              
              -- Set up mock buff
****0         WoWAPIMock.SetUnitBuff("target", 1, {
                  name = "Rejuvenation",
                  icon = "Interface\\Icons\\Spell_Nature_Rejuvenation",
                  count = 1,
                  debuffType = nil,
                  duration = 12,
                  expirationTime = GetTime() + 12,
                  source = "player",
                  isStealable = false,
                  nameplateShowPersonal = true,
****0             spellId = 774
              })
              
****0         local success, hasBuff = pcall(function()
****0             return HealIQ.Tracker:HasBuff("target", 774) -- Rejuvenation
              end)
              
****0         if success then
****0             Tests.AssertType("boolean", hasBuff, "Tracker: HasBuff returns boolean")
              end
          end
          
****0     if HealIQ.Tracker.GetBuffDuration then
****0         Tests.AssertType("function", HealIQ.Tracker.GetBuffDuration, "Tracker: GetBuffDuration is function")
              
****0         local success, duration = pcall(function()
****0             return HealIQ.Tracker:GetBuffDuration("target", 774)
              end)
              
****0         if success and duration then
****0             Tests.AssertType("number", duration, "Tracker: GetBuffDuration returns number")
****0             Tests.Assert(duration >= 0, "Tracker: Duration is non-negative")
              end
          end
          
          -- Test combat state tracking
****0     if HealIQ.Tracker.IsInCombat then
****0         Tests.AssertType("function", HealIQ.Tracker.IsInCombat, "Tracker: IsInCombat is function")
              
              -- Test with combat state false
****0         WoWAPIMock.SetGameState({inCombat = false})
              
****0         local success, inCombat = pcall(function()
****0             return HealIQ.Tracker:IsInCombat()
              end)
              
****0         if success then
****0             Tests.AssertType("boolean", inCombat, "Tracker: IsInCombat returns boolean")
              end
              
              -- Test with combat state true
****0         WoWAPIMock.SetGameState({inCombat = true})
              
****0         success, inCombat = pcall(function()
****0             return HealIQ.Tracker:IsInCombat()
              end)
              
****0         if success then
****0             Tests.AssertType("boolean", inCombat, "Tracker: IsInCombat returns boolean when in combat")
              end
          end
          
          -- Test spell tracking
****0     if HealIQ.Tracker.TrackSpellCast then
****0         Tests.AssertType("function", HealIQ.Tracker.TrackSpellCast, "Tracker: TrackSpellCast is function")
              
****0         local success = pcall(function()
****0             HealIQ.Tracker:TrackSpellCast(774, "target") -- Rejuvenation on target
              end)
****0         Tests.Assert(success, "Tracker: TrackSpellCast executes without error")
          end
          
          -- Test combat log processing
****0     if HealIQ.Tracker.ProcessCombatLogEvent then
****0         Tests.AssertType("function", HealIQ.Tracker.ProcessCombatLogEvent, "Tracker: ProcessCombatLogEvent is function")
              
              -- Add mock combat log event
****0         WoWAPIMock.AddCombatLogEvent(
****0             GetTime(), -- timestamp
                  "SPELL_AURA_APPLIED", -- subevent
                  false, -- hideCaster
                  "Player-1234-56789ABC", -- sourceGUID
                  "TestPlayer", -- sourceName
                  0x511, -- sourceFlags
                  0, -- sourceRaidFlags
                  "Creature-0-1234-56789-1-12345-000012345A", -- destGUID
                  "TestTarget", -- destName
                  0x10A48, -- destFlags
                  0, -- destRaidFlags
                  774, -- spellId
                  "Rejuvenation", -- spellName
                  1 -- spellSchool
              )
              
****0         local success = pcall(function()
****0             HealIQ.Tracker:ProcessCombatLogEvent()
              end)
****0         Tests.Assert(success, "Tracker: ProcessCombatLogEvent executes without error")
          end
      end

      -- Enhanced test runner that includes mocked tests
    2 function Tests.RunAllTestsEnhanced()
****0     Tests.Initialize()
          
          -- Run original tests
****0     Tests.TestCore()
****0     Tests.TestConfig()
****0     Tests.TestTracker()
****0     Tests.TestUI()
          
          -- Run enhanced mocked tests
****0     Tests.RunMockedEngineTests()
****0     Tests.RunMockedUITests()
****0     Tests.RunMockedTrackerTests()
          
          -- Generate comprehensive test report
****0     HealIQ:Print("\n=== Enhanced Test Results with WoW API Mocking ===")
****0     HealIQ:Print(string.format("Total Tests: %d", totalTests))
****0     HealIQ:Print(string.format("Passed: %d", passedTests))
****0     HealIQ:Print(string.format("Failed: %d", totalTests - passedTests))
****0     HealIQ:Print(string.format("Success Rate: %.1f%%", (passedTests / totalTests) * 100))
          
          -- Show failed tests
****0     local failedTests = {}
****0     for _, result in ipairs(testResults) do
****0         if not result.passed then
****0             table.insert(failedTests, result)
              end
          end
          
****0     if #failedTests > 0 then
****0         HealIQ:Print("\n=== Failed Tests ===")
****0         for _, result in ipairs(failedTests) do
****0             HealIQ:Print(string.format("FAIL: %s - %s", result.name, result.error))
              end
          else
****0         HealIQ:Print("\n🎉 All tests passed!")
          end
          
****0     return totalTests, passedTests
      end

    2 HealIQ.Tests = Tests

==============================================================================
Tracker.lua
==============================================================================
      -- HealIQ Tracker.lua
      -- Tracks buffs, cooldowns, and relevant unit conditions

   13 local addonName, HealIQ = ...

   13 HealIQ.Tracker = {}
   13 local Tracker = HealIQ.Tracker

      -- Spell IDs for tracking
   13 local SPELL_IDS = {
          -- Restoration Druid spells
   13     LIFEBLOOM = 33763,
   13     REJUVENATION = 774,
   13     REGROWTH = 8936,
   13     WILD_GROWTH = 48438,
   13     SWIFTMEND = 18562,
   13     CLEARCASTING = 16870,
          
          -- Major cooldowns
   13     IRONBARK = 102342,
   13     EFFLORESCENCE = 145205,
   13     TRANQUILITY = 740,
   13     INCARNATION_TREE = 33891,
   13     NATURES_SWIFTNESS = 132158,
   13     BARKSKIN = 22812,
   13     FLOURISH = 197721,
          
          -- New spells from strategy review
   13     GROVE_GUARDIANS = 102693,
   13     WRATH = 5176,
          
          -- Buffs
   13     CLEARCASTING_BUFF = 16870,
   13     IRONBARK_BUFF = 102342,
   13     BARKSKIN_BUFF = 22812,
   13     NATURES_SWIFTNESS_BUFF = 132158,
   13     INCARNATION_TREE_BUFF = 33891,
      }

      -- Track state
   13 local trackedData = {
   13     cooldowns = {},
   13     buffs = {},
   13     lastCombatLogTime = 0,
   13     recentDamage = {},
   13     targetHots = {},
   13     playerBuffs = {},
   13     trinketCooldowns = {},
   13     efflorescenceActive = false,
   13     efflorescenceExpires = 0,
      }

   13 function Tracker:Initialize()
****0     HealIQ:SafeCall(function()
****0         self:RegisterEvents()
****0         HealIQ:Print("Tracker initialized")
          end)
      end

   13 function Tracker:RegisterEvents()
****0     local frame = CreateFrame("Frame")
****0     frame:RegisterEvent("SPELL_UPDATE_COOLDOWN")
****0     frame:RegisterEvent("UNIT_AURA")
****0     frame:RegisterEvent("COMBAT_LOG_EVENT_UNFILTERED")
****0     frame:RegisterEvent("PLAYER_TARGET_CHANGED")
          
****0     frame:SetScript("OnEvent", function(self, event, ...)
****0         Tracker:OnEvent(event, ...)
          end)
      end

   13 function Tracker:OnEvent(event, ...)
****0     local args = {...}  -- Capture varargs for use in SafeCall
****0     HealIQ:SafeCall(function()
****0         if event == "SPELL_UPDATE_COOLDOWN" then
****0             self:UpdateCooldowns()
****0         elseif event == "UNIT_AURA" then
****0             local unit = args[1]
****0             self:UpdateUnitAuras(unit)
****0         elseif event == "COMBAT_LOG_EVENT_UNFILTERED" then
****0             self:ParseCombatLog()
****0         elseif event == "PLAYER_TARGET_CHANGED" then
****0             self:UpdateTargetHots()
              end
          end)
      end

   13 function Tracker:UpdateCooldowns()
****0     local currentTime = GetTime()
          
          -- Helper function to update cooldown data
          local function updateCooldown(spellId, spellName)
****0         local startTime, duration, isEnabled = C_Spell.GetSpellCooldown(spellId)
              -- Defensive check: ensure we got valid values and spell is on cooldown
****0         if startTime and duration and isEnabled and startTime > 0 and duration > 0 then
****0             local remaining = (startTime + duration) - currentTime
****0             trackedData.cooldowns[spellName] = {
                      remaining = math.max(0, remaining),
                      ready = remaining <= 0,
                      start = startTime,
****0                 duration = duration
                  }
              else
                  -- Clear any existing data when spell is not on cooldown
****0             trackedData.cooldowns[spellName] = nil
              end
          end
          
          -- Track existing spells
****0     updateCooldown(SPELL_IDS.WILD_GROWTH, "wildGrowth")
****0     updateCooldown(SPELL_IDS.SWIFTMEND, "swiftmend")
          
          -- Track new major cooldowns
****0     updateCooldown(SPELL_IDS.IRONBARK, "ironbark")
****0     updateCooldown(SPELL_IDS.EFFLORESCENCE, "efflorescence")
****0     updateCooldown(SPELL_IDS.TRANQUILITY, "tranquility")
****0     updateCooldown(SPELL_IDS.INCARNATION_TREE, "incarnationTree")
****0     updateCooldown(SPELL_IDS.NATURES_SWIFTNESS, "naturesSwiftness")
****0     updateCooldown(SPELL_IDS.BARKSKIN, "barkskin")
****0     updateCooldown(SPELL_IDS.FLOURISH, "flourish")
          
          -- Track new spells from strategy review
****0     updateCooldown(SPELL_IDS.GROVE_GUARDIANS, "groveGuardians")
****0     updateCooldown(SPELL_IDS.WRATH, "wrath")
          
          -- Track trinket cooldowns (slot 13 and 14)
****0     for slot = 13, 14 do
****0         local itemId = GetInventoryItemID("player", slot)
****0         if itemId then
****0             local startTime, duration, isEnabled = C_Item.GetItemCooldown(itemId)
                  -- Defensive check: ensure we got valid values and item is on cooldown
****0             if startTime and duration and isEnabled and startTime > 0 and duration > 0 then
****0                 local remaining = (startTime + duration) - currentTime
****0                 trackedData.trinketCooldowns[slot] = {
                          remaining = math.max(0, remaining),
                          ready = remaining <= 0,
                          start = startTime,
                          duration = duration,
****0                     itemId = itemId
                      }
                  else
                      -- Clear trinket cooldown data when not on cooldown
****0                 trackedData.trinketCooldowns[slot] = nil
                  end
              end
          end
      end

   13 function Tracker:UpdateUnitAuras(unit)
****0     if unit == "player" then
****0         self:UpdatePlayerBuffs()
****0     elseif unit == "target" or unit == "focus" then
****0         self:UpdateTargetHots()
          end
      end

   13 function Tracker:UpdatePlayerBuffs()
****0     local currentTime = GetTime()
          
          -- Helper function to check for buff
          local function checkBuff(spellId, buffName)
****0         local spellName = C_Spell.GetSpellName(spellId)
****0         if spellName then
****0             local auraData = C_UnitAuras.GetAuraDataBySpellName("player", spellName, "HELPFUL")
****0             if auraData then
****0                 trackedData.playerBuffs[buffName] = {
                          active = true,
                          remaining = auraData.expirationTime - currentTime,
****0                     stacks = auraData.applications or 1
                      }
                  else
****0                 trackedData.playerBuffs[buffName] = {
                          active = false,
                          remaining = 0,
****0                     stacks = 0
                      }
                  end
              else
****0             trackedData.playerBuffs[buffName] = {
                      active = false,
                      remaining = 0,
****0                 stacks = 0
                  }
              end
          end
          
          -- Check for existing buffs
****0     checkBuff(SPELL_IDS.CLEARCASTING_BUFF, "clearcasting")
          
          -- Check for new buffs
****0     checkBuff(SPELL_IDS.IRONBARK_BUFF, "ironbark")
****0     checkBuff(SPELL_IDS.BARKSKIN_BUFF, "barkskin")
****0     checkBuff(SPELL_IDS.NATURES_SWIFTNESS_BUFF, "naturesSwiftness")
****0     checkBuff(SPELL_IDS.INCARNATION_TREE_BUFF, "incarnationTree")
          
          -- Maintain backward compatibility
****0     trackedData.buffs.clearcasting = trackedData.playerBuffs.clearcasting
      end

   13 function Tracker:UpdateTargetHots()
****0     if not UnitExists("target") then
****0         trackedData.targetHots = {}
****0         return
          end
          
****0     local currentTime = GetTime()
          
          -- Check for Lifebloom on target
****0     local spellName = C_Spell.GetSpellName(SPELL_IDS.LIFEBLOOM)
****0     local auraData = spellName and C_UnitAuras.GetAuraDataBySpellName("target", spellName, "HELPFUL")
****0     if auraData then
****0         trackedData.targetHots.lifebloom = {
                  active = true,
                  remaining = auraData.expirationTime - currentTime,
****0             stacks = auraData.applications or 1
              }
          else
****0         trackedData.targetHots.lifebloom = {
                  active = false,
                  remaining = 0,
****0             stacks = 0
              }
          end
          
          -- Check for Rejuvenation on target
****0     spellName = C_Spell.GetSpellName(SPELL_IDS.REJUVENATION)
****0     auraData = spellName and C_UnitAuras.GetAuraDataBySpellName("target", spellName, "HELPFUL")
****0     if auraData then
****0         trackedData.targetHots.rejuvenation = {
                  active = true,
                  remaining = auraData.expirationTime - currentTime,
****0             stacks = auraData.applications or 1
              }
          else
****0         trackedData.targetHots.rejuvenation = {
                  active = false,
                  remaining = 0,
****0             stacks = 0
              }
          end
          
          -- Check for Regrowth on target
****0     spellName = C_Spell.GetSpellName(SPELL_IDS.REGROWTH)
****0     auraData = spellName and C_UnitAuras.GetAuraDataBySpellName("target", spellName, "HELPFUL")
****0     if auraData then
****0         trackedData.targetHots.regrowth = {
                  active = true,
                  remaining = auraData.expirationTime - currentTime,
****0             stacks = auraData.applications or 1
              }
          else
****0         trackedData.targetHots.regrowth = {
                  active = false,
                  remaining = 0,
****0             stacks = 0
              }
          end
      end

   13 function Tracker:ParseCombatLog()
****0     local timestamp, subevent, _, sourceGUID, sourceName, sourceFlags, sourceRaidFlags, destGUID, destName, destFlags, destRaidFlags = CombatLogGetCurrentEventInfo()
          
          -- Track recent damage for Wild Growth suggestions
****0     if subevent == "SWING_DAMAGE" or subevent == "SPELL_DAMAGE" or subevent == "RANGE_DAMAGE" then
****0         if UnitInParty(destName) or UnitInRaid(destName) then
****0             local currentTime = GetTime()
****0             trackedData.recentDamage[destGUID] = currentTime
                  
                  -- Clean up old damage records (older than 5 seconds)
                  -- Use separate cleanup pass to avoid performance issues
****0             local toRemove = {}
****0             for guid, time in pairs(trackedData.recentDamage) do
****0                 if currentTime - time > 5 then
****0                     table.insert(toRemove, guid)
                      end
                  end
                  
****0             for _, guid in ipairs(toRemove) do
****0                 trackedData.recentDamage[guid] = nil
                  end
              end
          end
          
          -- Track Efflorescence casting
****0     if subevent == "SPELL_CAST_SUCCESS" then
****0         local spellId = select(12, CombatLogGetCurrentEventInfo())
****0         if spellId == SPELL_IDS.EFFLORESCENCE and sourceGUID == UnitGUID("player") then
****0             trackedData.efflorescenceActive = true
****0             trackedData.efflorescenceExpires = GetTime() + 30 -- Efflorescence lasts 30 seconds
              end
          end
          
          -- Update efflorescence status
****0     if trackedData.efflorescenceActive and GetTime() > trackedData.efflorescenceExpires then
****0         trackedData.efflorescenceActive = false
          end
      end

      -- Public getter functions
   13 function Tracker:GetCooldownInfo(spellName)
****0     local cooldown = trackedData.cooldowns[spellName]
          -- Defensive check: ensure we return either nil or a valid table
****0     if cooldown and type(cooldown) == "table" then
****0         return cooldown
          end
****0     return nil
      end

   13 function Tracker:GetBuffInfo(buffName)
****0     return trackedData.buffs[buffName]
      end

   13 function Tracker:GetTargetHotInfo(hotName)
****0     return trackedData.targetHots[hotName]
      end

   13 function Tracker:GetRecentDamageCount()
****0     local count = 0
****0     local currentTime = GetTime()
          
          -- Use configurable time window from strategy settings
****0     local strategy = HealIQ.db and HealIQ.db.strategy or {}
****0     local timeWindow = strategy.recentDamageWindow or 3 -- default 3 seconds
          
****0     for guid, time in pairs(trackedData.recentDamage) do
****0         if currentTime - time <= timeWindow then
****0             count = count + 1
              end
          end
          
****0     return count
      end

   13 function Tracker:HasClearcasting()
****0     return trackedData.buffs.clearcasting and trackedData.buffs.clearcasting.active
      end

   13 function Tracker:IsSpellReady(spellName)
****0     local cooldown = trackedData.cooldowns[spellName]
****0     return cooldown and cooldown.ready
      end

   13 function Tracker:CanSwiftmend()
****0     local swiftmendReady = self:IsSpellReady("swiftmend")
****0     local hasRejuv = trackedData.targetHots.rejuvenation and trackedData.targetHots.rejuvenation.active
****0     local hasRegrowth = trackedData.targetHots.regrowth and trackedData.targetHots.regrowth.active
          
****0     return swiftmendReady and (hasRejuv or hasRegrowth)
      end

      -- New getter functions for additional spells
   13 function Tracker:GetPlayerBuffInfo(buffName)
****0     return trackedData.playerBuffs[buffName]
      end

   13 function Tracker:HasPlayerBuff(buffName)
****0     local buff = trackedData.playerBuffs[buffName]
****0     return buff and buff.active
      end

   13 function Tracker:GetTrinketCooldown(slot)
****0     return trackedData.trinketCooldowns[slot]
      end

   13 function Tracker:IsEfflorescenceActive()
****0     return trackedData.efflorescenceActive
      end

   13 function Tracker:GetEfflorescenceTimeRemaining()
****0     if trackedData.efflorescenceActive then
****0         return math.max(0, trackedData.efflorescenceExpires - GetTime())
          end
****0     return 0
      end

   13 function Tracker:ShouldUseIronbark()
          -- Suggest Ironbark if available and target is taking damage
****0     local ironbarkReady = self:IsSpellReady("ironbark")
****0     local targetExists = UnitExists("target")
****0     local targetIsFriendly = targetExists and UnitIsFriend("player", "target")
          
          -- Check if target doesn't already have Ironbark
****0     local hasIronbark = false
****0     if targetExists then
****0         local spellName = C_Spell.GetSpellName(SPELL_IDS.IRONBARK_BUFF)
****0         local auraData = spellName and C_UnitAuras.GetAuraDataBySpellName("target", spellName, "HELPFUL")
****0         hasIronbark = auraData ~= nil
          end
          
****0     return ironbarkReady and targetIsFriendly and not hasIronbark
      end

   13 function Tracker:ShouldUseEfflorescence()
          -- Suggest Efflorescence if available, not currently active, and multiple people took damage
****0     local efflorescenceReady = self:IsSpellReady("efflorescence")
****0     local notActive = not trackedData.efflorescenceActive
****0     local recentDamageCount = self:GetRecentDamageCount()
          
          -- Use configurable threshold
****0     local strategy = HealIQ.db and HealIQ.db.strategy or {}
****0     local minTargets = strategy.efflorescenceMinTargets or 2
          
****0     return efflorescenceReady and notActive and recentDamageCount >= minTargets
      end

   13 function Tracker:ShouldUseTranquility()
          -- Suggest Tranquility if available and high group damage
****0     local tranquilityReady = self:IsSpellReady("tranquility")
****0     local recentDamageCount = self:GetRecentDamageCount()
          
          -- Use configurable threshold
****0     local strategy = HealIQ.db and HealIQ.db.strategy or {}
****0     local minTargets = strategy.tranquilityMinTargets or 4
          
****0     return tranquilityReady and recentDamageCount >= minTargets
      end

   13 function Tracker:ShouldUseFlourish()
          -- Suggest Flourish if available and multiple HoTs are about to expire
****0     local flourishReady = self:IsSpellReady("flourish")
****0     local expiringHots = 0
          
          -- Use configurable threshold for expiring HoTs
****0     local strategy = HealIQ.db and HealIQ.db.strategy or {}
****0     local minHots = strategy.flourishMinHots or 2
****0     local expirationWindow = 6 -- HoTs expiring in next 6 seconds
          
          -- Check for expiring HoTs on target
****0     if UnitExists("target") then
****0         local rejuv = trackedData.targetHots.rejuvenation
****0         local regrowth = trackedData.targetHots.regrowth
****0         local lifebloom = trackedData.targetHots.lifebloom
              
****0         if rejuv and rejuv.active and rejuv.remaining < expirationWindow then
****0             expiringHots = expiringHots + 1
              end
****0         if regrowth and regrowth.active and regrowth.remaining < expirationWindow then
****0             expiringHots = expiringHots + 1
              end
****0         if lifebloom and lifebloom.active and lifebloom.remaining < expirationWindow then
****0             expiringHots = expiringHots + 1
              end
          end
          
****0     return flourishReady and expiringHots >= minHots
      end

   13 function Tracker:ShouldUseIncarnation()
          -- Suggest Incarnation during high damage phases
****0     local incarnationReady = self:IsSpellReady("incarnationTree")
****0     local recentDamageCount = self:GetRecentDamageCount()
          
          -- Use configurable threshold, but typically lower than Tranquility
****0     local strategy = HealIQ.db and HealIQ.db.strategy or {}
****0     local minTargets = strategy.wildGrowthMinTargets or 3
          
****0     return incarnationReady and recentDamageCount >= minTargets
      end

   13 function Tracker:ShouldUseNaturesSwiftness()
          -- Suggest Nature's Swiftness if available and target needs immediate healing
****0     local naturesSwiftnessReady = self:IsSpellReady("naturesSwiftness")
****0     local targetExists = UnitExists("target")
****0     local targetIsFriendly = targetExists and UnitIsFriend("player", "target")
          
          -- Enhanced logic: consider emergency situations and strategy settings
****0     local strategy = HealIQ.db and HealIQ.db.strategy or {}
****0     local isEmergency = false
          
          -- Check for emergency situations
****0     if targetExists and targetIsFriendly then
****0         local healthPercent = UnitHealth("target") / UnitHealthMax("target")
****0         local lowHealthThreshold = strategy.lowHealthThreshold or 0.3
****0         isEmergency = healthPercent <= lowHealthThreshold
          end
          
          -- Also consider emergency use based on strategy setting
****0     local emergencyUse = strategy.emergencyNaturesSwiftness ~= false -- default true
          
****0     return naturesSwiftnessReady and targetIsFriendly and (isEmergency or not emergencyUse)
      end

   13 function Tracker:ShouldUseBarkskin()
          -- Suggest Barkskin if available and player is taking damage
****0     local barkskinReady = self:IsSpellReady("barkskin")
****0     local inCombat = InCombatLockdown()
          
          -- Enhanced logic: consider player health and threat
****0     local playerHealthPercent = UnitHealth("player") / UnitHealthMax("player")
****0     local lowHealthThreshold = (HealIQ.db and HealIQ.db.strategy and HealIQ.db.strategy.lowHealthThreshold) or 0.5
          
****0     return barkskinReady and inCombat and (playerHealthPercent <= lowHealthThreshold)
      end

   13 function Tracker:ShouldUseGroveGuardians()
          -- Suggest Grove Guardians based on strategy - pool charges for big cooldowns
****0     local groveGuardiansReady = self:IsSpellReady("groveGuardians")
****0     local strategy = HealIQ.db and HealIQ.db.strategy or {}
****0     local poolCharges = strategy.poolGroveGuardians ~= false -- default true
          
****0     if not groveGuardiansReady then
****0         return false
          end
          
          -- If pooling is disabled, suggest whenever ready
****0     if not poolCharges then
****0         return true
          end
          
          -- Pool charges logic: only suggest during high damage phases or when other cooldowns are active
****0     local recentDamageCount = self:GetRecentDamageCount()
****0     local minTargets = strategy.wildGrowthMinTargets or 3
****0     local hasOtherCooldowns = self:HasPlayerBuff("incarnationTree") or self:HasPlayerBuff("naturesSwiftness")
          
****0     return recentDamageCount >= minTargets or hasOtherCooldowns
      end

   13 function Tracker:ShouldUseWrath()
          -- Suggest Wrath for mana restoration during downtime
****0     local wrathReady = not self:IsSpellReady("wrath") or true -- Wrath has no cooldown typically
****0     local strategy = HealIQ.db and HealIQ.db.strategy or {}
****0     local useForMana = strategy.useWrathForMana ~= false -- default true
          
****0     if not useForMana then
****0         return false
          end
          
          -- Only suggest Wrath during low activity periods
****0     local inCombat = InCombatLockdown()
****0     local recentDamageCount = self:GetRecentDamageCount()
****0     local hasTarget = UnitExists("target")
****0     local targetIsEnemy = hasTarget and UnitIsEnemy("player", "target")
          
          -- Suggest if:
          -- 1. Not in combat and have enemy target, OR
          -- 2. In combat but low damage activity and have enemy target, OR
          -- 3. No immediate healing needs
****0     local lowActivity = recentDamageCount == 0
****0     local noHealingNeeds = not self:HasImmediateHealingNeeds()
          
****0     return wrathReady and ((not inCombat and targetIsEnemy) or (inCombat and lowActivity and targetIsEnemy) or (inCombat and noHealingNeeds and targetIsEnemy))
      end

   13 function Tracker:HasImmediateHealingNeeds()
          -- Check if there are immediate healing needs
****0     local hasTarget = UnitExists("target")
****0     local targetIsFriendly = hasTarget and UnitIsFriend("player", "target")
          
****0     if targetIsFriendly then
              -- Check if target has low health
****0         local healthPercent = UnitHealth("target") / UnitHealthMax("target")
****0         local strategy = HealIQ.db and HealIQ.db.strategy or {}
****0         local lowHealthThreshold = strategy.lowHealthThreshold or 0.3
              
****0         if healthPercent <= lowHealthThreshold then
****0             return true
              end
              
              -- Check if target is missing important buffs
****0         local lifeboomInfo = self:GetTargetHotInfo("lifebloom")
****0         local rejuvInfo = self:GetTargetHotInfo("rejuvenation")
****0         local isTank = UnitGroupRolesAssigned("target") == "TANK"
****0         local isFocus = UnitIsUnit("target", "focus")
              
              -- Tank missing Lifebloom is high priority
****0         if (isTank or isFocus) and (not lifeboomInfo or not lifeboomInfo.active) then
****0             return true
              end
              
              -- Missing Rejuvenation during combat
****0         if InCombatLockdown() and (not rejuvInfo or not rejuvInfo.active) then
****0             return true
              end
          end
          
          -- Check for group damage
****0     local recentDamageCount = self:GetRecentDamageCount()
****0     return recentDamageCount >= 2
      end

   13 function Tracker:HasActiveTrinket()
          -- Check if any trinket is ready to use
****0     for slot = 13, 14 do
****0         local itemId = GetInventoryItemID("player", slot)
****0         if itemId then
****0             local startTime, duration, isEnabled = C_Item.GetItemCooldown(itemId)
                  -- Check if trinket has a use effect and is not on cooldown
****0             if isEnabled and (not startTime or startTime == 0 or duration == 0) then
                      -- Additional check to see if item has a use effect
****0                 if type(itemId) == "number" and itemId > 0 then
****0                     local item = Item:CreateFromItemID(itemId)
****0                     if item and item:IsItemDataCached() then
****0                         local itemSpell = C_Item.GetItemSpell(itemId)
****0                         if itemSpell then
****0                             return true, slot
                              end
                          end
                      end
                  end
              end
          end
****0     return false, nil
      end

   13 HealIQ.Tracker = Tracker

==============================================================================
UI.lua
==============================================================================
      -- HealIQ UI.lua
      -- Renders suggestion icons and manages configuration display

   13 local addonName, HealIQ = ...

   13 HealIQ.UI = {}
   13 local UI = HealIQ.UI

      -- UI Frame references
   13 local mainFrame = nil
      local iconFrame = nil
      local spellNameText = nil
      local cooldownFrame = nil
      local queueFrame = nil
   13 local queueIcons = {}
   13 local isDragging = false
   13 local minimapButton = nil
      local optionsFrame = nil

      -- Constants
   13 local FRAME_SIZE = 64
   13 local ICON_SIZE = 48
   13 local OPTIONS_FRAME_HEIGHT = 650  -- Increased height to accommodate all content
   13 local TOOLTIP_LINE_LENGTH = 45

      -- Minimap button positioning
   13 local MINIMAP_BUTTON_PIXEL_BUFFER = 2

      -- UI Border colors (configurable for accessibility)
   13 local BORDER_COLORS = {
   13     positioning = {0, 1, 1, 0.8},     -- Cyan for positioning aid
   13     locked = {1, 0, 0, 0.5},          -- Red when UI is locked
   13     unlocked = {0, 1, 0, 0.5},        -- Green when UI is unlocked
   13     targeting = {0, 0, 0, 0.8}        -- Dark border for targeting indicators
      }

      -- Texture paths
   13 local MINIMAP_BACKGROUND_TEXTURE = "Interface\\MINIMAP\\UI-Minimap-Background"

   13 function UI:Initialize()
****0     HealIQ:SafeCall(function()
****0         self:CreateMainFrame()
****0         self:CreateMinimapButton()
****0         self:CreateOptionsFrame()
****0         self:SetupEventHandlers()
****0         HealIQ:Print("UI initialized")
          end)
      end

   13 function UI:CreateMainFrame()
          -- Check if database is initialized before accessing UI settings
   18     if not HealIQ.db or not HealIQ.db.ui then
****0         HealIQ:LogError("UI:CreateMainFrame called before database initialization")
****0         return
          end
          
          -- Determine total frame size based on queue settings
   18     local queueSize = HealIQ.db.ui.queueSize or 3
   18     local queueLayout = HealIQ.db.ui.queueLayout or "horizontal"
   18     local queueSpacing = HealIQ.db.ui.queueSpacing or 8
   18     local queueScale = HealIQ.db.ui.queueScale or 0.75
   18     local queueIconSize = math.floor(ICON_SIZE * queueScale) -- Use same calculation as CreateQueueFrame
   18     local padding = 8 -- Consistent padding for all elements
          
   18     local frameWidth = FRAME_SIZE + (padding * 2)
   18     local frameHeight = FRAME_SIZE + (padding * 2)
          
   18     if HealIQ.db.ui.showQueue then
   18         if queueLayout == "horizontal" then
                  -- Fix: Add spacing between icon and queue, plus queue width
   14             local queueWidth = (queueSize - 1) * queueIconSize + math.max(0, queueSize - 2) * queueSpacing
   14             frameWidth = frameWidth + queueSpacing + queueWidth
              else
                  -- Account for spell name text in vertical layout
    4             local spellNameHeight = HealIQ.db.ui.showSpellName and 25 or 0  -- Match CreateQueueFrame offset
                  -- Fix: Add spacing between icon and queue, plus queue height
    4             local queueHeight = (queueSize - 1) * queueIconSize + math.max(0, queueSize - 2) * queueSpacing
    4             frameHeight = frameHeight + queueSpacing + spellNameHeight + queueHeight
              end
          end
          
          -- Create main container frame
   18     mainFrame = CreateFrame("Frame", "HealIQMainFrame", UIParent)
   18     mainFrame:SetSize(frameWidth, frameHeight)
   18     mainFrame:SetPoint("CENTER", UIParent, "CENTER", HealIQ.db.ui.x, HealIQ.db.ui.y)
   18     mainFrame:SetFrameStrata("MEDIUM")
****0     mainFrame:SetFrameLevel(100)
          
          -- Create background with improved styling that covers the entire frame for mouse events
****0     local bg = mainFrame:CreateTexture(nil, "BACKGROUND")
****0     bg:SetAllPoints(mainFrame)  -- Cover the entire frame area
****0     bg:SetColorTexture(0, 0, 0, 0.4)
****0     bg:SetAlpha(0.6)
          
          -- Create border for better visual definition with consistent padding
****0     local border = mainFrame:CreateTexture(nil, "BORDER")
****0     border:SetPoint("TOPLEFT", mainFrame, "TOPLEFT", padding - 1, -(padding - 1))
****0     border:SetPoint("BOTTOMRIGHT", mainFrame, "BOTTOMRIGHT", -(padding - 1), padding - 1)
****0     border:SetColorTexture(0.3, 0.3, 0.3, 0.8)
          
          -- Store border reference for ToggleLock function
****0     mainFrame.border = border
          
          -- Create primary spell icon frame (current suggestion) with consistent padding
****0     iconFrame = CreateFrame("Button", "HealIQIconFrame", mainFrame)
****0     iconFrame:SetSize(ICON_SIZE, ICON_SIZE)
****0     iconFrame:SetPoint("LEFT", mainFrame, "LEFT", padding + (FRAME_SIZE - ICON_SIZE) / 2, 0)
          
          -- Store current suggestion for tooltip display
****0     iconFrame.currentSuggestion = nil
          
          -- Create spell icon texture with improved styling
****0     local iconTexture = iconFrame:CreateTexture(nil, "ARTWORK")
****0     iconTexture:SetAllPoints()
****0     iconTexture:SetTexCoord(0.1, 0.9, 0.1, 0.9) -- Crop edges for cleaner look
****0     iconFrame.icon = iconTexture
          
          -- Create targeting indicator (small icon in corner)
****0     local targetingIcon = CreateFrame("Frame", "HealIQTargetingIcon", iconFrame)
****0     targetingIcon:SetSize(16, 16)
****0     targetingIcon:SetPoint("BOTTOMRIGHT", iconFrame, "BOTTOMRIGHT", -2, 2)
          
****0     local targetingTexture = targetingIcon:CreateTexture(nil, "OVERLAY")
****0     targetingTexture:SetAllPoints()
****0     targetingTexture:SetTexCoord(0.1, 0.9, 0.1, 0.9)
****0     targetingIcon.icon = targetingTexture
          
          -- Create targeting indicator border
****0     local targetingBorder = targetingIcon:CreateTexture(nil, "BORDER")
****0     targetingBorder:SetSize(18, 18)
****0     targetingBorder:SetPoint("CENTER")
****0     targetingBorder:SetColorTexture(unpack(BORDER_COLORS.targeting))
****0     targetingIcon.border = targetingBorder
          
****0     iconFrame.targetingIcon = targetingIcon
          
          -- Create glow effect for primary icon
****0     local glow = iconFrame:CreateTexture(nil, "OVERLAY")
****0     glow:SetSize(ICON_SIZE + 8, ICON_SIZE + 8)
****0     glow:SetPoint("CENTER")
****0     glow:SetColorTexture(1, 1, 0, 0.4) -- Yellow glow
****0     glow:SetBlendMode("ADD")
****0     iconFrame.glow = glow
          
          -- Create pulsing animation for the glow
****0     local glowAnimation = glow:CreateAnimationGroup()
****0     glowAnimation:SetLooping("BOUNCE")
          
****0     local fadeIn = glowAnimation:CreateAnimation("Alpha")
****0     fadeIn:SetFromAlpha(0.2)
****0     fadeIn:SetToAlpha(0.6)
****0     fadeIn:SetDuration(1.0)
****0     fadeIn:SetSmoothing("IN_OUT")
          
****0     local fadeOut = glowAnimation:CreateAnimation("Alpha")
****0     fadeOut:SetFromAlpha(0.6)
****0     fadeOut:SetToAlpha(0.2)
****0     fadeOut:SetDuration(1.0)
****0     fadeOut:SetSmoothing("IN_OUT")
          
****0     glowAnimation:Play()
****0     iconFrame.glowAnimation = glowAnimation
          
          -- Add click handler for viewing spell information (removed casting functionality)
****0     iconFrame:SetScript("OnClick", function(self, button)
              -- Spell casting removed due to Blizzard restrictions
****0         if self.currentSuggestion then
****0             HealIQ:Print("Suggested: " .. self.currentSuggestion.name)
              end
          end)
          
          -- Add tooltip functionality for the main icon
****0     iconFrame:SetScript("OnEnter", function(self)
****0         if self.currentSuggestion then
****0             GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
****0             GameTooltip:AddLine(self.currentSuggestion.name, 1, 1, 1)
****0             GameTooltip:AddLine("Suggested spell for current situation", 0.7, 0.7, 0.7)
                  
****0             if self.currentSuggestion.priority then
****0                 GameTooltip:AddLine("Priority: " .. self.currentSuggestion.priority, 0.5, 0.8, 1)
                  end
                  
                  -- Add targeting suggestions
****0             if HealIQ.Engine then
****0                 local targetText = HealIQ.Engine:GetTargetingSuggestionsText(self.currentSuggestion)
****0                 local targetDesc = HealIQ.Engine:GetTargetingSuggestionsDescription(self.currentSuggestion)
                      
****0                 if targetText then
****0                     GameTooltip:AddLine(" ")
****0                     GameTooltip:AddLine("Suggested Target: " .. targetText, 1, 0.8, 0)
****0                     if targetDesc then
****0                         GameTooltip:AddLine(targetDesc, 0.8, 0.8, 0.8)
                          end
                      end
                  end
                  
****0             GameTooltip:Show()
              end
          end)
          
****0     iconFrame:SetScript("OnLeave", function(self)
****0         GameTooltip:Hide()
          end)
          
          -- Create spell name text with consistent spacing
****0     spellNameText = mainFrame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
****0     spellNameText:SetPoint("TOP", iconFrame, "BOTTOM", 0, -4) -- Consistent spacing
****0     spellNameText:SetTextColor(1, 1, 1, 1)
****0     spellNameText:SetShadowColor(0, 0, 0, 1)
****0     spellNameText:SetShadowOffset(1, -1)
****0     spellNameText:SetJustifyH("CENTER") -- Center-align the text
****0     spellNameText:SetJustifyV("TOP") -- Top-align for multi-line support
****0     spellNameText:SetWidth(120) -- Set a max width to prevent overflow
          
          -- Create cooldown frame
****0     cooldownFrame = CreateFrame("Cooldown", "HealIQCooldownFrame", iconFrame, "CooldownFrameTemplate")
****0     cooldownFrame:SetAllPoints()
****0     cooldownFrame:SetDrawEdge(false)
****0     cooldownFrame:SetDrawSwipe(true)
****0     cooldownFrame:SetReverse(true)
          
          -- Create queue frame
****0     self:CreateQueueFrame()
          
          -- Make frame draggable
****0     self:MakeFrameDraggable()
          
          -- Update position border based on current settings
          -- This call is necessary here because the frame border needs to be initialized
          -- after all frame components are created and the database is available
****0     self:UpdatePositionBorder()
          
          -- Initially hide the frame
****0     mainFrame:Hide()
      end

      -- Helper function for minimap button positioning
   13 function UI:CalculateMinimapButtonRadius()
****0     if not minimapButton then
****0         return 1
          end
          
****0     local minimapRadius = Minimap:GetWidth() / 2
****0     local buttonRadius = minimapButton:GetWidth() / 2
          -- Fixed: Use minimapRadius + MINIMAP_BUTTON_PIXEL_BUFFER to place button ON the edge
****0     local radius = minimapRadius + MINIMAP_BUTTON_PIXEL_BUFFER
          
****0     if radius <= 0 then
****0         radius = 1 -- Ensure a minimum positive radius
          end
          
****0     return radius
      end

   13 function UI:CreateMinimapButton()
****0     if not HealIQ.db or not HealIQ.db.ui then
****0         HealIQ:LogError("UI:CreateMinimapButton called before database initialization")
****0         return
          end
          
          -- Create minimap button
****0     minimapButton = CreateFrame("Button", "HealIQMinimapButton", Minimap)
****0     minimapButton:SetSize(32, 32)
****0     minimapButton:SetFrameStrata("MEDIUM")
****0     minimapButton:SetFrameLevel(8)
          
          -- Create button border first (visible border around the icon)
****0     local border = minimapButton:CreateTexture(nil, "BORDER")
****0     border:SetSize(22, 22)
****0     border:SetPoint("CENTER")
****0     border:SetColorTexture(0.8, 0.8, 0.8, 0.9)  -- Light gray border
          
          -- Create circular mask for the border
****0     local borderMask = minimapButton:CreateMaskTexture()
****0     borderMask:SetAllPoints(border)
****0     borderMask:SetTexture(MINIMAP_BACKGROUND_TEXTURE, "CLAMPTOBLACKADDITIVE", "CLAMPTOBLACKADDITIVE")
****0     border:AddMaskTexture(borderMask)
          
          -- Create button background with circular masking
****0     local bg = minimapButton:CreateTexture(nil, "BACKGROUND")
****0     bg:SetSize(18, 18)  -- Slightly smaller than border
****0     bg:SetPoint("CENTER")
****0     bg:SetColorTexture(0, 0, 0, 0.7)
          
          -- Create circular mask for the background
****0     local mask = minimapButton:CreateMaskTexture()
****0     mask:SetAllPoints(bg)
****0     mask:SetTexture(MINIMAP_BACKGROUND_TEXTURE, "CLAMPTOBLACKADDITIVE", "CLAMPTOBLACKADDITIVE")
****0     bg:AddMaskTexture(mask)
          
          -- Create button icon with circular masking
****0     local icon = minimapButton:CreateTexture(nil, "ARTWORK")
****0     icon:SetSize(14, 14)  -- Adjusted to fit within border
****0     icon:SetPoint("CENTER")
****0     icon:SetTexture("Interface\\Icons\\Spell_Nature_Rejuvenation")
****0     icon:SetTexCoord(0.1, 0.9, 0.1, 0.9)
          
          -- Apply circular mask to the icon as well
****0     local iconMask = minimapButton:CreateMaskTexture()
****0     iconMask:SetAllPoints(icon)
****0     iconMask:SetTexture(MINIMAP_BACKGROUND_TEXTURE, "CLAMPTOBLACKADDITIVE", "CLAMPTOBLACKADDITIVE")
****0     icon:AddMaskTexture(iconMask)
          
****0     minimapButton.icon = icon
****0     minimapButton.border = border  -- Store reference for potential updates
          
          -- Position on minimap using angle-based positioning
****0     local savedAngle = HealIQ.db.ui.minimapAngle or -math.pi/4 -- Default to top-right
****0     local radius = self:CalculateMinimapButtonRadius()
          
          -- Fixed: Position relative to Minimap center, not UIParent
****0     local x = radius * math.cos(savedAngle)
****0     local y = radius * math.sin(savedAngle)
****0     minimapButton:SetPoint("CENTER", Minimap, "CENTER", x, y)
          
          -- Make it draggable around minimap
****0     minimapButton:SetMovable(true)
****0     minimapButton:EnableMouse(true)
****0     minimapButton:RegisterForDrag("LeftButton")
          
****0     minimapButton:SetScript("OnDragStart", function(self)
****0         self:StartMoving()
              -- Store original border visibility
****0         if self.icon then
****0             self.originalAlpha = self.icon:GetAlpha()
              end
          end)
          
****0     minimapButton:SetScript("OnDragStop", function(self)
****0         self:StopMovingOrSizing()
              -- Keep button on minimap edge and save position
****0         local dragX, dragY = self:GetCenter()
****0         local mapX, mapY = Minimap:GetCenter()
****0         local angle = math.atan2(dragY - mapY, dragX - mapX)
              
              -- Use helper method for radius calculation
****0         local finalRadius = UI:CalculateMinimapButtonRadius()
              
              -- Fixed: Position relative to Minimap center, not UIParent
****0         local newX = finalRadius * math.cos(angle)
****0         local newY = finalRadius * math.sin(angle)
****0         self:ClearAllPoints()
****0         self:SetPoint("CENTER", Minimap, "CENTER", newX, newY)
              
              -- Restore icon visibility if it was affected
****0         if self.icon and self.originalAlpha then
****0             self.icon:SetAlpha(self.originalAlpha)
              end
              
              -- Save minimap button position as angle for consistency
****0         if HealIQ.db and HealIQ.db.ui then
****0             HealIQ.db.ui.minimapAngle = angle
              end
          end)
          
          -- Click handler
****0     minimapButton:SetScript("OnClick", function(self, button)
****0         if button == "LeftButton" then
****0             UI:ToggleOptionsFrame()
****0         elseif button == "RightButton" then
****0             UI:Toggle()
              end
          end)
          
          -- Tooltip
****0     minimapButton:SetScript("OnEnter", function(self)
****0         GameTooltip:SetOwner(self, "ANCHOR_LEFT")
****0         GameTooltip:AddLine("HealIQ v" .. HealIQ.version, 1, 1, 1)
****0         GameTooltip:AddLine("Smart healing suggestions for Restoration Druids", 0.8, 0.8, 0.8)
****0         GameTooltip:AddLine(" ")
****0         GameTooltip:AddLine("Left-click: Open Options", 0.7, 0.7, 0.7)
****0         GameTooltip:AddLine("Right-click: Toggle Display", 0.7, 0.7, 0.7)
****0         GameTooltip:AddLine("Drag: Move Button", 0.7, 0.7, 0.7)
****0         GameTooltip:Show()
          end)
          
****0     minimapButton:SetScript("OnLeave", function(self)
****0         GameTooltip:Hide()
          end)
          
          -- Set initial visibility based on showIcon setting
****0     self:UpdateMinimapButtonVisibility()
      end

   13 function UI:UpdateMinimapButtonVisibility()
****0     if minimapButton and HealIQ.db and HealIQ.db.ui then
****0         if HealIQ.db.ui.showIcon then
****0             minimapButton:Show()
              else
****0             minimapButton:Hide()
              end
          end
      end

   13 function UI:CreateQueueFrame()
****0     if not HealIQ.db or not HealIQ.db.ui then
****0         HealIQ:LogError("UI:CreateQueueFrame called before database initialization")
****0         return
          end
          
****0     local queueSize = HealIQ.db.ui.queueSize or 3
****0     local queueLayout = HealIQ.db.ui.queueLayout or "horizontal"
****0     local queueSpacing = HealIQ.db.ui.queueSpacing or 8
****0     local queueIconSize = math.floor(ICON_SIZE * (HealIQ.db.ui.queueScale or 0.75)) -- Configurable queue icon size
****0     local padding = 8 -- Consistent with main frame padding
          
          -- Create queue container frame (always create, but conditionally show)
****0     queueFrame = CreateFrame("Frame", "HealIQQueueFrame", mainFrame)
          
****0     if queueLayout == "horizontal" then
              -- Fix: Adjust frame size calculation to account for proper spacing
****0         local totalWidth = (queueSize - 1) * queueIconSize + math.max(0, queueSize - 2) * queueSpacing
****0         queueFrame:SetSize(totalWidth, queueIconSize)
****0         queueFrame:SetPoint("LEFT", iconFrame, "RIGHT", queueSpacing, 0)
          else
              -- Fix: Adjust frame size calculation for vertical layout
****0         local totalHeight = (queueSize - 1) * queueIconSize + math.max(0, queueSize - 2) * queueSpacing
****0         queueFrame:SetSize(queueIconSize, totalHeight)
              -- Better vertical positioning that accounts for spell name text and padding
****0         local verticalOffset = HealIQ.db.ui.showSpellName and -(queueSpacing + 25) or -(queueSpacing + padding)
****0         queueFrame:SetPoint("TOP", iconFrame, "BOTTOM", 0, verticalOffset)
          end
          
          -- Create queue icons
****0     queueIcons = {}
****0     for i = 1, queueSize - 1 do -- -1 because primary icon is separate
****0         local queueIcon = CreateFrame("Frame", "HealIQQueueIcon" .. i, queueFrame)
****0         queueIcon:SetSize(queueIconSize, queueIconSize)
              
****0         if queueLayout == "horizontal" then
****0             queueIcon:SetPoint("LEFT", queueFrame, "LEFT", (i - 1) * (queueIconSize + queueSpacing), 0)
              else
****0             queueIcon:SetPoint("TOP", queueFrame, "TOP", 0, -(i - 1) * (queueIconSize + queueSpacing))
              end
              
              -- Create icon texture
****0         local texture = queueIcon:CreateTexture(nil, "ARTWORK")
****0         texture:SetAllPoints()
****0         texture:SetTexCoord(0.1, 0.9, 0.1, 0.9)
****0         texture:SetAlpha(0.7) -- Slightly transparent for queue items
****0         queueIcon.icon = texture
              
              -- Create border for queue items with improved visibility
****0         local border = queueIcon:CreateTexture(nil, "BORDER")
****0         border:SetSize(queueIconSize + 2, queueIconSize + 2)
****0         border:SetPoint("CENTER")
****0         border:SetColorTexture(0.3, 0.6, 1, 0.8) -- Blue border for queue items
****0         queueIcon.border = border
              
              -- Add subtle shadow effect
****0         local shadow = queueIcon:CreateTexture(nil, "BACKGROUND")
****0         shadow:SetSize(queueIconSize + 4, queueIconSize + 4)
****0         shadow:SetPoint("CENTER", queueIcon, "CENTER", 2, -2)
****0         shadow:SetColorTexture(0, 0, 0, 0.5)
****0         queueIcon.shadow = shadow
              
              -- Add position number overlay with better positioning for vertical layout
****0         local positionText = queueIcon:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
****0         if queueLayout == "vertical" then
****0             positionText:SetPoint("LEFT", queueIcon, "RIGHT", 6, 0) -- Consistent spacing
              else
****0             positionText:SetPoint("BOTTOMRIGHT", queueIcon, "BOTTOMRIGHT", -2, 2)
              end
****0         positionText:SetTextColor(1, 1, 1, 0.9)
****0         positionText:SetText(tostring(i + 1)) -- +1 because primary is position 1
****0         positionText:SetShadowColor(0, 0, 0, 1)
****0         positionText:SetShadowOffset(1, -1)
****0         queueIcon.positionText = positionText
              
              -- Initially hide queue icons
****0         queueIcon:Hide()
              
****0         table.insert(queueIcons, queueIcon)
          end
          
          -- Show/hide queue frame based on settings
****0     if HealIQ.db.ui.showQueue then
****0         queueFrame:Show()
          else
****0         queueFrame:Hide()
          end
      end

   13 function UI:CreateOptionsFrame()
          -- Create main options frame with reduced height
****0     optionsFrame = CreateFrame("Frame", "HealIQOptionsFrame", UIParent, "BasicFrameTemplateWithInset")
****0     optionsFrame:SetSize(400, OPTIONS_FRAME_HEIGHT) -- Reduced height, content will be organized in tabs
****0     optionsFrame:SetPoint("CENTER")
****0     optionsFrame:SetFrameStrata("DIALOG")
****0     optionsFrame:SetMovable(true)
****0     optionsFrame:EnableMouse(true)
****0     optionsFrame:RegisterForDrag("LeftButton")
****0     optionsFrame:SetScript("OnDragStart", optionsFrame.StartMoving)
****0     optionsFrame:SetScript("OnDragStop", optionsFrame.StopMovingOrSizing)
          
          -- Add icon to title bar
****0     local titleIcon = optionsFrame:CreateTexture(nil, "ARTWORK")
****0     titleIcon:SetSize(16, 16)
****0     titleIcon:SetPoint("LEFT", optionsFrame.TitleBg, "LEFT", 8, 0)
****0     titleIcon:SetTexture("Interface\\Icons\\Spell_Nature_Rejuvenation")
****0     titleIcon:SetTexCoord(0.1, 0.9, 0.1, 0.9)
          
          -- Title
****0     optionsFrame.title = optionsFrame:CreateFontString(nil, "OVERLAY", "GameFontHighlightLarge")
****0     optionsFrame.title:SetPoint("LEFT", titleIcon, "RIGHT", 5, 0)
****0     optionsFrame.title:SetText("HealIQ Options")
          
          -- Version display
****0     optionsFrame.version = optionsFrame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
****0     optionsFrame.version:SetPoint("RIGHT", optionsFrame.TitleBg, "RIGHT", -5, 0)
****0     optionsFrame.version:SetText("v" .. HealIQ.version)
****0     optionsFrame.version:SetTextColor(0.7, 0.7, 0.7, 1)
          
          -- Content area
****0     local content = optionsFrame.Inset or optionsFrame
          
          -- Create tab system
****0     self:CreateOptionsTabs(content)
          
          -- Close button
****0     local closeButton = CreateFrame("Button", "HealIQCloseButton", content, "UIPanelButtonTemplate")
****0     closeButton:SetSize(80, 22)
****0     closeButton:SetPoint("BOTTOMRIGHT", content, "BOTTOMRIGHT", -10, 10)
****0     closeButton:SetText("Close")
****0     closeButton:SetScript("OnClick", function()
****0         optionsFrame:Hide()
          end)
          
          -- Initially hide
****0     optionsFrame:Hide()
          
          -- Update options with current values once frame is created
****0     self:UpdateOptionsFrame()
      end

   13 function UI:CreateOptionsTabs(parent)
          -- Create navigation sidebar and content area
****0     local navWidth = 110  -- Width of the left navigation sidebar
****0     local navButtonHeight = 28
****0     local navButtonSpacing = 2
****0     local tabs = {
****0         {name = "General", id = "general"},
****0         {name = "Display", id = "display"},
****0         {name = "Rules", id = "rules"},
****0         {name = "Strategy", id = "strategy"},
****0         {name = "Queue", id = "queue"}
          }
          
****0     optionsFrame.tabs = {}
****0     optionsFrame.tabPanels = {}
****0     optionsFrame.activeTab = nil  -- Initialize activeTab to avoid nil reference issues
          
          -- Create navigation background
****0     local navBackground = CreateFrame("Frame", "HealIQNavBackground", parent, "BackdropTemplate")
****0     navBackground:SetPoint("TOPLEFT", parent, "TOPLEFT", 10, -10)
          -- Make navigation height responsive to frame height
****0     local navHeight = OPTIONS_FRAME_HEIGHT - 80  -- Increased padding for better fit
****0     navBackground:SetSize(navWidth, navHeight)
****0     navBackground:SetBackdrop({
              bgFile = "Interface\\Tooltips\\UI-Tooltip-Background",
              edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
              tile = true,
              tileSize = 8,
              edgeSize = 8,
****0         insets = { left = 2, right = 2, top = 2, bottom = 2 }
          })
****0     navBackground:SetBackdropColor(0.05, 0.05, 0.1, 0.8)
****0     navBackground:SetBackdropBorderColor(0.3, 0.3, 0.4, 0.8)
          
****0     for i, tab in ipairs(tabs) do
              -- Create navigation button
****0         local navButton = CreateFrame("Button", "HealIQNav" .. tab.id, navBackground, "UIPanelButtonTemplate")
****0         navButton:SetSize(navWidth - 10, navButtonHeight)
****0         navButton:SetPoint("TOP", navBackground, "TOP", 0, -5 - (i-1) * (navButtonHeight + navButtonSpacing))
****0         navButton:SetText(tab.name)
****0         navButton.tabId = tab.id
              
              -- Style the navigation button for sidebar appearance
****0         navButton:SetNormalFontObject("GameFontNormal")
****0         navButton:SetHighlightFontObject("GameFontHighlight")
****0         navButton:SetDisabledFontObject("GameFontDisable")
              
              -- Set initial inactive appearance
****0         navButton:SetAlpha(0.8)
              
              -- Add hover effects
****0         navButton:SetScript("OnEnter", function(self)
****0             if not optionsFrame.activeTab or self.tabId ~= optionsFrame.activeTab then
****0                 self:SetAlpha(0.95)
                  end
              end)
              
****0         navButton:SetScript("OnLeave", function(self)
****0             if not optionsFrame.activeTab or self.tabId ~= optionsFrame.activeTab then
****0                 self:SetAlpha(0.8)
                  end
              end)
              
****0         navButton:SetScript("OnClick", function(self)
****0             UI:ShowOptionsTab(self.tabId)
              end)
              
****0         optionsFrame.tabs[tab.id] = navButton
              
              -- Create content panel - positioned to the right of navigation
****0         local panel = CreateFrame("Frame", "HealIQPanel" .. tab.id, parent)
****0         panel:SetPoint("TOPLEFT", parent, "TOPLEFT", navWidth + 20, -10)
****0         panel:SetPoint("BOTTOMRIGHT", parent, "BOTTOMRIGHT", -10, 40)
****0         panel:Hide()
              
****0         optionsFrame.tabPanels[tab.id] = panel
          end
          
          -- Create content for each tab
****0     self:CreateGeneralTab(optionsFrame.tabPanels.general)
****0     self:CreateDisplayTab(optionsFrame.tabPanels.display)
****0     self:CreateRulesTab(optionsFrame.tabPanels.rules)
****0     self:CreateStrategyTab(optionsFrame.tabPanels.strategy)
****0     self:CreateQueueTab(optionsFrame.tabPanels.queue)
          
          -- Show first tab by default
****0     self:ShowOptionsTab("general")
      end
   13 function UI:ShowOptionsTab(tabId)
          -- Hide all panels and reset navigation button states
****0     for id, panel in pairs(optionsFrame.tabPanels) do
****0         panel:Hide()
              -- Reset button appearance for inactive navigation items
****0         local navButton = optionsFrame.tabs[id]
****0         navButton:SetAlpha(0.8)
****0         navButton:SetNormalFontObject("GameFontNormal")
          end
          
          -- Show selected panel and mark navigation item as active
****0     if optionsFrame.tabPanels[tabId] then
****0         optionsFrame.tabPanels[tabId]:Show()
              -- Highlight the active navigation button
****0         local activeButton = optionsFrame.tabs[tabId]
****0         activeButton:SetAlpha(1.0)
****0         activeButton:SetNormalFontObject("GameFontHighlight")
              
              -- Track the active tab for hover effects
****0         optionsFrame.activeTab = tabId
          end
      end

   13 function UI:CreateGeneralTab(panel)
****0     local yOffset = -10
          
          -- General Settings Section
****0     local generalHeader = panel:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
****0     generalHeader:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     generalHeader:SetText("General Settings")
****0     generalHeader:SetTextColor(1, 0.8, 0, 1)
****0     yOffset = yOffset - 30
          
          -- Enable/Disable checkbox
****0     local enableCheck = CreateFrame("CheckButton", "HealIQEnableCheck", panel, "UICheckButtonTemplate")
****0     enableCheck:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     enableCheck.text = enableCheck:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0     enableCheck.text:SetPoint("LEFT", enableCheck, "RIGHT", 5, 0)
****0     enableCheck.text:SetText("Enable HealIQ")
****0     enableCheck:SetScript("OnClick", function(self)
****0         if HealIQ.db then
****0             HealIQ.db.enabled = self:GetChecked()
****0             if HealIQ.UI then
****0                 HealIQ.UI:SetEnabled(HealIQ.db.enabled)
                  end
              end
          end)
****0     self:AddTooltip(enableCheck, "Enable HealIQ", "Enable or disable the entire HealIQ addon.\nWhen disabled, no suggestions will be shown.")
****0     optionsFrame.enableCheck = enableCheck
****0     yOffset = yOffset - 30
          
          -- Debug mode checkbox
****0     local debugCheck = CreateFrame("CheckButton", "HealIQDebugCheck", panel, "UICheckButtonTemplate")
****0     debugCheck:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     debugCheck.text = debugCheck:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0     debugCheck.text:SetPoint("LEFT", debugCheck, "RIGHT", 5, 0)
****0     debugCheck.text:SetText("Enable Debug Mode")
****0     debugCheck:SetScript("OnClick", function(self)
****0         if HealIQ.db then
****0             HealIQ.db.debug = self:GetChecked()
****0             HealIQ.debug = HealIQ.db.debug
****0             if HealIQ.debug then
****0                 HealIQ:Print("Debug mode enabled")
                  else
****0                 HealIQ:Print("Debug mode disabled")
                  end
              end
          end)
****0     self:AddTooltip(debugCheck, "Enable Debug Mode", "Enable additional debug output and test features.\nUseful for troubleshooting issues.")
****0     optionsFrame.debugCheck = debugCheck
****0     yOffset = yOffset - 30
          
          -- Session stats checkbox
****0     local statsCheck = CreateFrame("CheckButton", "HealIQStatsCheck", panel, "UICheckButtonTemplate")
****0     statsCheck:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     statsCheck.text = statsCheck:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0     statsCheck.text:SetPoint("LEFT", statsCheck, "RIGHT", 5, 0)
****0     statsCheck.text:SetText("Session Statistics")
****0     statsCheck:SetScript("OnClick", function(self)
****0         local enabled = self:GetChecked()
****0         if enabled then
****0             if not HealIQ.sessionStats then
****0                 HealIQ.sessionStats = {
                          startTime = time(),
                          suggestions = 0,
                          rulesProcessed = 0,
                          errorsLogged = 0,
                          eventsHandled = 0,
                      }
****0             elseif not HealIQ.sessionStats.startTime then
****0                 HealIQ.sessionStats.startTime = time()
                  end
****0             HealIQ:Message("Session statistics enabled")
              else
****0             if HealIQ.sessionStats then
****0                 HealIQ.sessionStats.startTime = nil
                  end
****0             HealIQ:Message("Session statistics disabled")
              end
          end)
****0     self:AddTooltip(statsCheck, "Session Statistics", "Track session statistics like suggestions generated, rules processed, etc.\nView statistics with /healiq status or /healiq dump.")
****0     optionsFrame.statsCheck = statsCheck
****0     yOffset = yOffset - 50
          
          -- UI Position Section
****0     local positionHeader = panel:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
****0     positionHeader:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     positionHeader:SetText("Position Settings")
****0     positionHeader:SetTextColor(1, 0.8, 0, 1)
****0     yOffset = yOffset - 30
          
          -- UI Position buttons
****0     local resetPosButton = CreateFrame("Button", "HealIQResetPosButton", panel, "UIPanelButtonTemplate")
****0     resetPosButton:SetSize(120, 22)
****0     resetPosButton:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     resetPosButton:SetText("Reset UI Position")
****0     resetPosButton:SetScript("OnClick", function()
****0         if HealIQ.UI then
****0             HealIQ.UI:ResetPosition()
              end
          end)
****0     self:AddTooltip(resetPosButton, "Reset UI Position", "Moves the main HealIQ display back to the center of the screen.")
****0     yOffset = yOffset - 30
          
****0     local lockButton = CreateFrame("Button", "HealIQLockButton", panel, "UIPanelButtonTemplate")
****0     lockButton:SetSize(100, 22)
****0     lockButton:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     lockButton:SetText("Lock UI")
****0     lockButton:SetScript("OnClick", function()
****0         if HealIQ.UI then
****0             HealIQ.UI:ToggleLock()
****0             UI:UpdateOptionsFrame()
              end
          end)
****0     self:AddTooltip(lockButton, "Lock/Unlock UI Position", "When unlocked, you can drag the main UI to move it.\nRight-click the main UI to toggle lock state.")
****0     optionsFrame.lockButton = lockButton
****0     yOffset = yOffset - 30
          
          -- Frame positioning indicator checkbox
****0     local showFrameCheck = CreateFrame("CheckButton", "HealIQShowFrameCheck", panel, "UICheckButtonTemplate")
****0     showFrameCheck:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     showFrameCheck.text = showFrameCheck:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0     showFrameCheck.text:SetPoint("LEFT", showFrameCheck, "RIGHT", 5, 0)
****0     showFrameCheck.text:SetText("Show frame positioning border")
****0     showFrameCheck:SetScript("OnClick", function(self)
****0         if HealIQ.db and HealIQ.db.ui then
****0             HealIQ.db.ui.showPositionBorder = self:GetChecked()
****0             if HealIQ.UI then
****0                 HealIQ.UI:UpdatePositionBorder()
                  end
              end
          end)
****0     self:AddTooltip(showFrameCheck, "Show Frame Position Border", "Shows a visible border around the main frame for easier positioning.\nHelpful when arranging the UI layout.")
****0     optionsFrame.showFrameCheck = showFrameCheck
****0     yOffset = yOffset - 30
          
          -- Minimap button reset
****0     local minimapResetButton = CreateFrame("Button", "HealIQMinimapResetButton", panel, "UIPanelButtonTemplate")
****0     minimapResetButton:SetSize(140, 22)
****0     minimapResetButton:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     minimapResetButton:SetText("Reset Minimap Icon")
****0     minimapResetButton:SetScript("OnClick", function()
****0         if HealIQ.UI then
****0             HealIQ.UI:ResetMinimapPosition()
              end
          end)
****0     self:AddTooltip(minimapResetButton, "Reset Minimap Icon Position", "Moves the minimap icon back to its default position.")
      end
   13 function UI:CreateDisplayTab(panel)
****0     local yOffset = -10
          
          -- Display Settings Section
****0     local displayHeader = panel:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
****0     displayHeader:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     displayHeader:SetText("Display Settings")
****0     displayHeader:SetTextColor(1, 0.8, 0, 1)
****0     yOffset = yOffset - 30
          
          -- UI Scale slider (Main UI)
****0     local scaleSlider = CreateFrame("Slider", "HealIQScaleSlider", panel, "OptionsSliderTemplate")
****0     scaleSlider:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     scaleSlider:SetMinMaxValues(0.5, 2.0)
****0     scaleSlider:SetValueStep(0.1)
****0     scaleSlider:SetObeyStepOnDrag(true)
****0     scaleSlider.tooltipText = "Adjust the scale of the main suggestion display"
****0     _G[scaleSlider:GetName() .. "Low"]:SetText("0.5")
****0     _G[scaleSlider:GetName() .. "High"]:SetText("2.0")
****0     _G[scaleSlider:GetName() .. "Text"]:SetText("Main UI Scale")
****0     scaleSlider:SetScript("OnValueChanged", function(self, value)
****0         if HealIQ.UI then
****0             HealIQ.UI:SetScale(value)
              end
          end)
****0     self:AddTooltip(scaleSlider, "Main UI Scale", "Adjust the scale of the main HealIQ display (0.5-2.0).")
****0     optionsFrame.scaleSlider = scaleSlider
****0     yOffset = yOffset - 40
          
          -- Display options
****0     local showNameCheck = CreateFrame("CheckButton", "HealIQShowNameCheck", panel, "UICheckButtonTemplate")
****0     showNameCheck:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     showNameCheck.text = showNameCheck:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0     showNameCheck.text:SetPoint("LEFT", showNameCheck, "RIGHT", 5, 0)
****0     showNameCheck.text:SetText("Show spell names")
****0     showNameCheck:SetScript("OnClick", function(self)
****0         if HealIQ.db and HealIQ.db.ui then
****0             HealIQ.db.ui.showSpellName = self:GetChecked()
****0             if HealIQ.UI then
****0                 HealIQ.UI:SetShowSpellName(self:GetChecked())
                  end
              end
          end)
****0     self:AddTooltip(showNameCheck, "Show Spell Names", "Display the name of the suggested spell below the icon.")
****0     optionsFrame.showNameCheck = showNameCheck
****0     yOffset = yOffset - 30
          
****0     local showCooldownCheck = CreateFrame("CheckButton", "HealIQShowCooldownCheck", panel, "UICheckButtonTemplate")
****0     showCooldownCheck:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     showCooldownCheck.text = showCooldownCheck:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0     showCooldownCheck.text:SetPoint("LEFT", showCooldownCheck, "RIGHT", 5, 0)
****0     showCooldownCheck.text:SetText("Show cooldown spirals")
****0     showCooldownCheck:SetScript("OnClick", function(self)
****0         if HealIQ.db and HealIQ.db.ui then
****0             HealIQ.db.ui.showCooldown = self:GetChecked()
****0             if HealIQ.UI then
****0                 HealIQ.UI:SetShowCooldown(self:GetChecked())
                  end
              end
          end)
****0     self:AddTooltip(showCooldownCheck, "Show Cooldown Spirals", "Display cooldown sweep animations on suggestion icons.")
****0     optionsFrame.showCooldownCheck = showCooldownCheck
****0     yOffset = yOffset - 30
          
****0     local showIconCheck = CreateFrame("CheckButton", "HealIQShowIconCheck", panel, "UICheckButtonTemplate")
****0     showIconCheck:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     showIconCheck.text = showIconCheck:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0     showIconCheck.text:SetPoint("LEFT", showIconCheck, "RIGHT", 5, 0)
****0     showIconCheck.text:SetText("Show minimap icon")
****0     showIconCheck:SetScript("OnClick", function(self)
****0         if HealIQ.db and HealIQ.db.ui then
****0             HealIQ.db.ui.showIcon = self:GetChecked()
****0             if HealIQ.UI then
****0                 HealIQ.UI:UpdateMinimapButtonVisibility()
                  end
              end
          end)
****0     self:AddTooltip(showIconCheck, "Show Minimap Icon", "Display the HealIQ minimap button.")
****0     optionsFrame.showIconCheck = showIconCheck
****0     yOffset = yOffset - 30
          
          -- Targeting display options
****0     local showTargetingCheck = CreateFrame("CheckButton", "HealIQShowTargetingCheck", panel, "UICheckButtonTemplate")
****0     showTargetingCheck:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     showTargetingCheck.text = showTargetingCheck:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0     showTargetingCheck.text:SetPoint("LEFT", showTargetingCheck, "RIGHT", 5, 0)
****0     showTargetingCheck.text:SetText("Show targeting suggestions")
****0     showTargetingCheck:SetScript("OnClick", function(self)
****0         if HealIQ.db and HealIQ.db.ui then
****0             HealIQ.db.ui.showTargeting = self:GetChecked()
                  -- Force UI update to refresh targeting display
****0             if HealIQ.Engine then
****0                 HealIQ.Engine:ForceUpdate()
                  end
              end
          end)
****0     self:AddTooltip(showTargetingCheck, "Show Targeting Suggestions", "Display suggested targets for spells in the spell name and tooltips.")
****0     optionsFrame.showTargetingCheck = showTargetingCheck
****0     yOffset = yOffset - 30
          
****0     local showTargetingIconCheck = CreateFrame("CheckButton", "HealIQShowTargetingIconCheck", panel, "UICheckButtonTemplate")
****0     showTargetingIconCheck:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     showTargetingIconCheck.text = showTargetingIconCheck:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0     showTargetingIconCheck.text:SetPoint("LEFT", showTargetingIconCheck, "RIGHT", 5, 0)
****0     showTargetingIconCheck.text:SetText("Show targeting icons")
****0     showTargetingIconCheck:SetScript("OnClick", function(self)
****0         if HealIQ.db and HealIQ.db.ui then
****0             HealIQ.db.ui.showTargetingIcon = self:GetChecked()
                  -- Force UI update to refresh targeting display
****0             if HealIQ.Engine then
****0                 HealIQ.Engine:ForceUpdate()
                  end
              end
          end)
****0     self:AddTooltip(showTargetingIconCheck, "Show Targeting Icons", "Display small targeting indicator icons overlaid on spell suggestions.")
****0     optionsFrame.showTargetingIconCheck = showTargetingIconCheck
      end

   13 function UI:CreateQueueTab(panel)
****0     local yOffset = -10
          
          -- Queue Settings Section
****0     local queueHeader = panel:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
****0     queueHeader:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     queueHeader:SetText("Queue Display Settings")
****0     queueHeader:SetTextColor(1, 0.8, 0, 1)
****0     yOffset = yOffset - 30
          
          -- Queue options
****0     local showQueueCheck = CreateFrame("CheckButton", "HealIQShowQueueCheck", panel, "UICheckButtonTemplate")
****0     showQueueCheck:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     showQueueCheck.text = showQueueCheck:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0     showQueueCheck.text:SetPoint("LEFT", showQueueCheck, "RIGHT", 5, 0)
****0     showQueueCheck.text:SetText("Show suggestion queue")
****0     showQueueCheck:SetScript("OnClick", function(self)
****0         if HealIQ.db and HealIQ.db.ui then
****0             HealIQ.db.ui.showQueue = self:GetChecked()
****0             if HealIQ.UI then
****0                 HealIQ.UI:RecreateFrames()
                  end
              end
          end)
****0     self:AddTooltip(showQueueCheck, "Show Suggestion Queue", "Display upcoming spell suggestions in a queue next to the main icon.")
****0     optionsFrame.showQueueCheck = showQueueCheck
****0     yOffset = yOffset - 40
          
          -- Queue Scale slider
****0     local queueScaleSlider = CreateFrame("Slider", "HealIQQueueScaleSlider", panel, "OptionsSliderTemplate")
****0     queueScaleSlider:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     queueScaleSlider:SetMinMaxValues(0.5, 1.5)
****0     queueScaleSlider:SetValueStep(0.1)
****0     queueScaleSlider:SetObeyStepOnDrag(true)
****0     queueScaleSlider.tooltipText = "Adjust the scale of the queue icons relative to main icon"
****0     _G[queueScaleSlider:GetName() .. "Low"]:SetText("0.5")
****0     _G[queueScaleSlider:GetName() .. "High"]:SetText("1.5")
****0     _G[queueScaleSlider:GetName() .. "Text"]:SetText("Queue Scale")
****0     queueScaleSlider:SetScript("OnValueChanged", function(self, value)
****0         if HealIQ.db and HealIQ.db.ui then
****0             HealIQ.db.ui.queueScale = value
****0             if HealIQ.UI then
****0                 HealIQ.UI:RecreateFrames()
                  end
              end
          end)
****0     self:AddTooltip(queueScaleSlider, "Queue Scale", "Adjust the scale of queue icons relative to the main icon (0.5-1.5).")
****0     optionsFrame.queueScaleSlider = queueScaleSlider
****0     yOffset = yOffset - 50
          
          -- Queue size slider
****0     local queueSizeSlider = CreateFrame("Slider", "HealIQQueueSizeSlider", panel, "OptionsSliderTemplate")
****0     queueSizeSlider:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     queueSizeSlider:SetMinMaxValues(2, 5)
****0     queueSizeSlider:SetValueStep(1)
****0     queueSizeSlider:SetObeyStepOnDrag(true)
****0     queueSizeSlider.tooltipText = "Number of suggestions to show in queue"
****0     _G[queueSizeSlider:GetName() .. "Low"]:SetText("2")
****0     _G[queueSizeSlider:GetName() .. "High"]:SetText("5")
****0     _G[queueSizeSlider:GetName() .. "Text"]:SetText("Queue Size")
****0     queueSizeSlider:SetScript("OnValueChanged", function(self, value)
****0         if HealIQ.db and HealIQ.db.ui then
****0             HealIQ.db.ui.queueSize = math.floor(value)
****0             if HealIQ.UI then
****0                 HealIQ.UI:RecreateFrames()
                  end
              end
          end)
****0     self:AddTooltip(queueSizeSlider, "Queue Size", "Number of spell suggestions to show in the queue (2-5).")
****0     optionsFrame.queueSizeSlider = queueSizeSlider
****0     yOffset = yOffset - 50
          
          -- Queue layout dropdown
****0     local queueLayoutLabel = panel:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0     queueLayoutLabel:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     queueLayoutLabel:SetText("Queue Layout:")
          
****0     local queueLayoutButton = CreateFrame("Button", "HealIQQueueLayoutButton", panel, "UIPanelButtonTemplate")
****0     queueLayoutButton:SetSize(100, 22)
****0     queueLayoutButton:SetPoint("LEFT", queueLayoutLabel, "RIGHT", 10, 0)
****0     queueLayoutButton:SetText("Horizontal")
****0     queueLayoutButton:SetScript("OnClick", function(self)
****0         if HealIQ.db and HealIQ.db.ui then
****0             local newLayout = HealIQ.db.ui.queueLayout == "horizontal" and "vertical" or "horizontal"
****0             HealIQ.db.ui.queueLayout = newLayout
****0             self:SetText(newLayout:sub(1,1):upper() .. newLayout:sub(2))
****0             if HealIQ.UI then
****0                 HealIQ.UI:RecreateFrames()
                  end
              end
          end)
****0     self:AddTooltip(queueLayoutButton, "Queue Layout", "Choose whether to display the queue horizontally or vertically.")
****0     optionsFrame.queueLayoutButton = queueLayoutButton
      end
   13 function UI:CreateRulesTab(panel)
****0     local yOffset = -10
          
          -- Rules section
****0     local rulesHeader = panel:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
****0     rulesHeader:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     rulesHeader:SetText("Suggestion Rules")
****0     rulesHeader:SetTextColor(1, 0.8, 0, 1)
****0     yOffset = yOffset - 30
          
****0     local rulesDesc = panel:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
****0     rulesDesc:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     rulesDesc:SetText("Enable or disable specific healing suggestions")
****0     rulesDesc:SetTextColor(0.8, 0.8, 0.8, 1)
****0     yOffset = yOffset - 25
          
          -- Rule checkboxes organized into categories
****0     local rules = {
              -- Emergency spells
****0         {key = "tranquility", name = "Tranquility (major AoE cooldown)", category = "Emergency"},
****0         {key = "incarnationTree", name = "Incarnation (transformation)", category = "Emergency"},
****0         {key = "naturesSwiftness", name = "Nature's Swiftness (instant cast)", category = "Emergency"},
              
              -- Core healing
****0         {key = "wildGrowth", name = "Wild Growth (AoE healing)", category = "Core"},
****0         {key = "efflorescence", name = "Efflorescence (ground AoE)", category = "Core"},
****0         {key = "swiftmend", name = "Swiftmend (combo)", category = "Core"},
****0         {key = "clearcasting", name = "Clearcasting (Regrowth proc)", category = "Core"},
              
              -- HoT management
****0         {key = "lifebloom", name = "Lifebloom (refresh)", category = "HoTs"},
****0         {key = "rejuvenation", name = "Rejuvenation (coverage)", category = "HoTs"},
****0         {key = "flourish", name = "Flourish (extend HoTs)", category = "HoTs"},
              
              -- Utility
****0         {key = "ironbark", name = "Ironbark (damage reduction)", category = "Utility"},
****0         {key = "barkskin", name = "Barkskin (self-defense)", category = "Utility"},
          }
          
****0     optionsFrame.ruleChecks = {}
          local currentCategory = nil
****0     local categoryYOffset = 0
          
****0     for i, rule in ipairs(rules) do
              -- Add category header if needed
****0         if rule.category ~= currentCategory then
****0             currentCategory = rule.category
****0             categoryYOffset = yOffset - 10
                  
****0             local categoryHeader = panel:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0             categoryHeader:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, categoryYOffset)
****0             categoryHeader:SetText(rule.category .. " Spells:")
****0             categoryHeader:SetTextColor(0.8, 1, 0.8, 1)
****0             yOffset = categoryYOffset - 25
              end
              
****0         local check = CreateFrame("CheckButton", "HealIQRule" .. rule.key, panel, "UICheckButtonTemplate")
****0         check:SetPoint("TOPLEFT", panel, "TOPLEFT", 20, yOffset)
****0         check.text = check:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0         check.text:SetPoint("LEFT", check, "RIGHT", 5, 0)
****0         check.text:SetText(rule.name)
              -- Add width constraint to prevent text overflow in rules tab
****0         check.text:SetWidth(240)  -- Leave room for navigation sidebar
****0         check.text:SetJustifyH("LEFT")
****0         check.text:SetWordWrap(true)
****0         check:SetScript("OnClick", function(self)
****0             if HealIQ.db and HealIQ.db.rules then
****0                 HealIQ.db.rules[rule.key] = self:GetChecked()
                  end
              end)
              
              -- Add tooltip for each rule
****0         local tooltipText = self:GetRuleTooltip(rule.key)
****0         if tooltipText then
****0             self:AddTooltip(check, rule.name, tooltipText)
              end
              
****0         optionsFrame.ruleChecks[rule.key] = check
****0         yOffset = yOffset - 25
          end
      end

   13 function UI:GetRuleTooltip(ruleKey)
****0     local tooltips = {
              wildGrowth = "Suggests Wild Growth when multiple party members have taken recent damage.",
              clearcasting = "Suggests using Regrowth when you have a Clearcasting proc.",
              lifebloom = "Suggests refreshing Lifebloom on your target when it's about to expire.",
              swiftmend = "Suggests Swiftmend when target has HoTs and needs immediate healing.",
              rejuvenation = "Suggests applying Rejuvenation for basic HoT coverage.",
              ironbark = "Suggests Ironbark for damage reduction on targets taking heavy damage.",
              efflorescence = "Suggests Efflorescence for AoE ground healing when group is stacked.",
              tranquility = "Suggests Tranquility during high group-wide damage situations.",
              incarnationTree = "Suggests Incarnation for enhanced healing during intensive phases.",
              naturesSwiftness = "Suggests Nature's Swiftness for instant cast emergency healing.",
              barkskin = "Suggests Barkskin for personal damage reduction in combat.",
              flourish = "Suggests Flourish to extend multiple expiring HoTs.",
          }
****0     return tooltips[ruleKey]
      end

   13 function UI:CreateStrategyTab(panel)
****0     local yOffset = -10
          
          -- Strategy section
****0     local strategyHeader = panel:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
****0     strategyHeader:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     strategyHeader:SetText("Healing Strategy Settings")
****0     strategyHeader:SetTextColor(1, 0.8, 0, 1)
****0     yOffset = yOffset - 30
          
****0     local strategyDesc = panel:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
****0     strategyDesc:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     strategyDesc:SetText("Configure enhanced healing strategy based on Wowhead guide")
****0     strategyDesc:SetTextColor(0.8, 0.8, 0.8, 1)
****0     yOffset = yOffset - 25
          
          -- Create a scrollable frame for strategy options
****0     local scrollFrame = CreateFrame("ScrollFrame", "HealIQStrategyScrollFrame", panel, "UIPanelScrollFrameTemplate")
****0     scrollFrame:SetPoint("TOPLEFT", panel, "TOPLEFT", 0, yOffset)
****0     scrollFrame:SetPoint("BOTTOMRIGHT", panel, "BOTTOMRIGHT", -25, 10)
          
****0     local scrollChild = CreateFrame("Frame", "HealIQStrategyScrollChild", scrollFrame)
          -- Make scroll child height responsive to avoid overflow issues
****0     local availableWidth = 350
****0     local contentHeight = 900  -- Increased to ensure all content fits
****0     scrollChild:SetSize(availableWidth, contentHeight)
****0     scrollFrame:SetScrollChild(scrollChild)
          
****0     local scrollYOffset = -10
          
          -- Core Strategy Toggles Section
****0     local coreHeader = scrollChild:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0     coreHeader:SetPoint("TOPLEFT", scrollChild, "TOPLEFT", 0, scrollYOffset)
****0     coreHeader:SetText("Core Strategy Toggles:")
****0     coreHeader:SetTextColor(0.8, 1, 0.8, 1)
****0     scrollYOffset = scrollYOffset - 25
          
          -- Store strategy controls for updating
****0     optionsFrame.strategyControls = {}
          
          -- Core toggle settings
****0     local coreToggles = {
****0         {key = "prioritizeEfflorescence", name = "Prioritize Efflorescence", desc = "Keep Efflorescence active frequently"},
****0         {key = "maintainLifebloomOnTank", name = "Maintain Lifebloom on Tank", desc = "Always keep Lifebloom on tank with proper refresh timing"},
****0         {key = "preferClearcastingRegrowth", name = "Prefer Clearcasting Regrowth", desc = "Prioritize Regrowth when you have Clearcasting procs"},
****0         {key = "swiftmendWildGrowthCombo", name = "Swiftmend + Wild Growth Combo", desc = "Link Swiftmend and Wild Growth usage"},
****0         {key = "avoidRandomRejuvenationDowntime", name = "Avoid Random Rejuvenation in Downtime", desc = "Don't cast random Rejuvenations during downtime periods"},
****0         {key = "useWrathForMana", name = "Use Wrath for Mana", desc = "Fill downtime with Wrath for mana restoration"},
****0         {key = "poolGroveGuardians", name = "Pool Grove Guardians", desc = "Pool Grove Guardian charges for major cooldowns"},
****0         {key = "emergencyNaturesSwiftness", name = "Emergency Nature's Swiftness", desc = "Use Nature's Swiftness for emergency healing"},
          }
          
****0     for _, toggle in ipairs(coreToggles) do
****0         local check = CreateFrame("CheckButton", "HealIQStrategy" .. toggle.key, scrollChild, "UICheckButtonTemplate")
****0         check:SetPoint("TOPLEFT", scrollChild, "TOPLEFT", 0, scrollYOffset)
****0         check.text = check:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0         check.text:SetPoint("LEFT", check, "RIGHT", 5, 0)
****0         check.text:SetText(toggle.name)
              -- Add width constraint to prevent text overflow
****0         check.text:SetWidth(280)  -- Leave room for checkbox and scrollbar
****0         check.text:SetJustifyH("LEFT")
****0         check.text:SetWordWrap(true)  -- Allow text wrapping for long names
****0         check:SetScript("OnClick", function(self)
****0             if HealIQ.db and HealIQ.db.strategy then
****0                 HealIQ.db.strategy[toggle.key] = self:GetChecked()
                      -- Force engine update to apply changes
****0                 if HealIQ.Engine then
****0                     HealIQ.Engine:ForceUpdate()
                      end
                  end
              end)
              
****0         self:AddTooltip(check, toggle.name, toggle.desc)
****0         optionsFrame.strategyControls[toggle.key] = check
****0         scrollYOffset = scrollYOffset - 25
          end
          
****0     scrollYOffset = scrollYOffset - 15
          
          -- Tunable Thresholds Section
****0     local thresholdsHeader = scrollChild:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0     thresholdsHeader:SetPoint("TOPLEFT", scrollChild, "TOPLEFT", 0, scrollYOffset)
****0     thresholdsHeader:SetText("Tunable Thresholds:")
****0     thresholdsHeader:SetTextColor(0.8, 1, 0.8, 1)
****0     scrollYOffset = scrollYOffset - 25
          
          -- Numeric settings with sliders
****0     local numericSettings = {
****0         {key = "lifebloomRefreshWindow", name = "Lifebloom Refresh Window", desc = "Refresh Lifebloom within this many seconds for bloom effect", min = 2, max = 8, step = 0.5},
****0         {key = "wildGrowthMinTargets", name = "Wild Growth Min Targets", desc = "Minimum targets damaged to suggest Wild Growth", min = 2, max = 6, step = 1},
****0         {key = "tranquilityMinTargets", name = "Tranquility Min Targets", desc = "Minimum targets damaged to suggest Tranquility", min = 3, max = 8, step = 1},
****0         {key = "efflorescenceMinTargets", name = "Efflorescence Min Targets", desc = "Minimum targets damaged to suggest Efflorescence", min = 2, max = 6, step = 1},
****0         {key = "flourishMinHots", name = "Flourish Min HoTs", desc = "Minimum expiring HoTs to suggest Flourish", min = 2, max = 6, step = 1},
****0         {key = "rejuvenationRampThreshold", name = "Rejuvenation Ramp Threshold", desc = "Start ramping Rejuvenation when damage expected in this many seconds", min = 5, max = 30, step = 1},
****0         {key = "recentDamageWindow", name = "Recent Damage Window", desc = "Time window to consider 'recent damage' (seconds)", min = 1, max = 10, step = 1},
****0         {key = "lowHealthThreshold", name = "Low Health Threshold", desc = "Health percentage to consider 'emergency' (0.0-1.0)", min = 0.1, max = 0.8, step = 0.05},
          }
          
****0     for _, setting in ipairs(numericSettings) do
              -- Setting label
****0         local label = scrollChild:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0         label:SetPoint("TOPLEFT", scrollChild, "TOPLEFT", 0, scrollYOffset)
****0         label:SetText(setting.name .. ":")
****0         scrollYOffset = scrollYOffset - 20
              
              -- Slider
****0         local slider = CreateFrame("Slider", "HealIQStrategy" .. setting.key .. "Slider", scrollChild, "OptionsSliderTemplate")
****0         slider:SetPoint("TOPLEFT", scrollChild, "TOPLEFT", 0, scrollYOffset)
****0         slider:SetMinMaxValues(setting.min, setting.max)
****0         slider:SetValueStep(setting.step)
****0         slider:SetObeyStepOnDrag(true)
****0         slider.tooltipText = setting.desc
****0         _G[slider:GetName() .. "Low"]:SetText(tostring(setting.min))
****0         _G[slider:GetName() .. "High"]:SetText(tostring(setting.max))
****0         _G[slider:GetName() .. "Text"]:SetText("")
              
              -- Value display
****0         local valueText = scrollChild:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
****0         valueText:SetPoint("RIGHT", slider, "RIGHT", 30, 0)
****0         valueText:SetTextColor(1, 1, 0, 1)
              
****0         slider:SetScript("OnValueChanged", function(self, value)
****0             if HealIQ.db and HealIQ.db.strategy then
****0                 HealIQ.db.strategy[setting.key] = value
****0                 valueText:SetText(string.format("%.1f", value))
                      -- Force engine update to apply changes
****0                 if HealIQ.Engine then
****0                     HealIQ.Engine:ForceUpdate()
                      end
                  end
              end)
              
****0         self:AddTooltip(slider, setting.name, setting.desc)
****0         optionsFrame.strategyControls[setting.key] = {slider = slider, valueText = valueText}
****0         scrollYOffset = scrollYOffset - 40
          end
          
****0     scrollYOffset = scrollYOffset - 15
          
          -- Talent Optimization Section
****0     local talentHeader = scrollChild:CreateFontString(nil, "OVERLAY", "GameFontNormal")
****0     talentHeader:SetPoint("TOPLEFT", scrollChild, "TOPLEFT", 0, scrollYOffset)
****0     talentHeader:SetText("Talent Optimization:")
****0     talentHeader:SetTextColor(0.8, 1, 0.8, 1)
****0     scrollYOffset = scrollYOffset - 25
          
          -- Talent status frame
****0     local talentFrame = CreateFrame("Frame", "HealIQTalentFrame", scrollChild, "BackdropTemplate")
****0     talentFrame:SetPoint("TOPLEFT", scrollChild, "TOPLEFT", 0, scrollYOffset)
****0     talentFrame:SetSize(350, 120)
****0     talentFrame:SetBackdrop({
              bgFile = "Interface\\Tooltips\\UI-Tooltip-Background",
              edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
              tile = true,
              tileSize = 8,
              edgeSize = 8,
****0         insets = { left = 2, right = 2, top = 2, bottom = 2 }
          })
****0     talentFrame:SetBackdropColor(0.1, 0.1, 0.2, 0.8)
****0     talentFrame:SetBackdropBorderColor(0.4, 0.4, 0.6, 1)
          
          -- Talent status text
****0     local talentStatusText = talentFrame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
****0     talentStatusText:SetPoint("TOPLEFT", talentFrame, "TOPLEFT", 8, -8)
****0     talentStatusText:SetText("Checking talents...")
****0     talentStatusText:SetTextColor(1, 1, 1, 1)
****0     talentStatusText:SetWidth(330)
****0     talentStatusText:SetJustifyH("LEFT")
          
          -- Refresh button for talent check
****0     local refreshButton = CreateFrame("Button", "HealIQTalentRefreshButton", talentFrame, "UIPanelButtonTemplate")
****0     refreshButton:SetSize(80, 20)
****0     refreshButton:SetPoint("BOTTOMRIGHT", talentFrame, "BOTTOMRIGHT", -5, 5)
****0     refreshButton:SetText("Refresh")
****0     refreshButton:SetScript("OnClick", function()
****0         UI:UpdateTalentStatus(talentStatusText)
          end)
****0     self:AddTooltip(refreshButton, "Refresh Talent Check", "Updates the talent optimization status based on your current talent build.")
          
          -- Store reference for updates
****0     optionsFrame.talentStatusText = talentStatusText
          
****0     scrollYOffset = scrollYOffset - 130
          
          -- Reset button
****0     local resetButton = CreateFrame("Button", "HealIQStrategyResetButton", scrollChild, "UIPanelButtonTemplate")
****0     resetButton:SetSize(120, 22)
****0     resetButton:SetPoint("TOPLEFT", scrollChild, "TOPLEFT", 0, scrollYOffset)
****0     resetButton:SetText("Reset to Defaults")
****0     resetButton:SetScript("OnClick", function()
              -- Reset strategy settings to defaults
****0         if HealIQ.db and HealIQ.db.strategy then
****0             local defaults = {
                      prioritizeEfflorescence = true,
                      maintainLifebloomOnTank = true,
                      lifebloomRefreshWindow = 4.5,
                      preferClearcastingRegrowth = true,
                      swiftmendWildGrowthCombo = true,
                      rejuvenationRampThreshold = 15,
                      avoidRandomRejuvenationDowntime = true,
                      useWrathForMana = true,
                      poolGroveGuardians = true,
                      emergencyNaturesSwiftness = true,
                      wildGrowthMinTargets = 3,
                      tranquilityMinTargets = 4,
                      efflorescenceMinTargets = 2,
                      flourishMinHots = 2,
                      recentDamageWindow = 3,
                      lowHealthThreshold = 0.3,
                  }
                  
****0             for setting, defaultValue in pairs(defaults) do
****0                 HealIQ.db.strategy[setting] = defaultValue
                  end
                  
                  -- Update the UI controls
****0             UI:UpdateOptionsFrame()
                  
                  -- Force engine update
****0             if HealIQ.Engine then
****0                 HealIQ.Engine:ForceUpdate()
                  end
                  
****0             HealIQ:Print("Strategy settings reset to defaults")
              end
          end)
****0     self:AddTooltip(resetButton, "Reset Strategy Settings", "Resets all strategy settings to their optimal default values.")
          
****0     scrollYOffset = scrollYOffset - 30
          
          -- Help text
****0     local helpText = scrollChild:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
****0     helpText:SetPoint("TOPLEFT", scrollChild, "TOPLEFT", 0, scrollYOffset)
****0     helpText:SetText("Strategy settings can also be configured via chat commands:\n/healiq strategy list - View all settings\n/healiq strategy set <setting> <value> - Change a setting")
****0     helpText:SetTextColor(0.7, 0.7, 0.7, 1)
****0     helpText:SetWidth(320)
****0     helpText:SetJustifyH("LEFT")
      end

   13 function UI:UpdateTalentStatus(talentStatusText)
****0     if not HealIQ.Engine then
****0         talentStatusText:SetText("Engine not available")
****0         return
          end
          
****0     local recommendations = HealIQ.Engine:GetTalentRecommendations()
****0     local statusLines = {}
          
          -- Add summary line
****0     table.insert(statusLines, recommendations.summary)
****0     table.insert(statusLines, "")
          
          -- Add critical missing talents (if any)
****0     if #recommendations.critical > 0 then
****0         table.insert(statusLines, "|cFFFF4444Critical Missing Talents:|r")
****0         for _, talent in ipairs(recommendations.critical) do
****0             table.insert(statusLines, "• " .. talent.name .. " - " .. talent.description)
              end
****0         table.insert(statusLines, "")
          end
          
          -- Add suggested missing talents (if any)
****0     if #recommendations.suggested > 0 then
****0         table.insert(statusLines, "|cFFFFAA44Recommended Talents:|r")
****0         for i, talent in ipairs(recommendations.suggested) do
****0             if i <= 3 then -- Limit to first 3 to fit in the frame
****0                 table.insert(statusLines, "• " .. talent.name .. " (" .. talent.category .. ")")
                  end
              end
****0         if #recommendations.suggested > 3 then
****0             table.insert(statusLines, "• ..." .. (#recommendations.suggested - 3) .. " more recommended talents")
              end
          end
          
          -- If everything is optimal, show a positive message
****0     if #recommendations.critical == 0 and #recommendations.suggested == 0 then
****0         table.insert(statusLines, "|cFF44FF44Your talent build is optimized for the healing strategy!|r")
****0         table.insert(statusLines, "")
****0         table.insert(statusLines, "All key talents for HealIQ's healing priority system are available.")
          end
          
****0     local statusText = table.concat(statusLines, "\n")
****0     talentStatusText:SetText(statusText)
      end

   13 function UI:AddTooltip(frame, title, description)
****0     frame:SetScript("OnEnter", function(self)
****0         GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
****0         GameTooltip:AddLine(title, 1, 1, 1)
****0         if description then
                  -- Split long descriptions into multiple lines
****0             local words = {}
****0             for word in description:gmatch("%S+") do
****0                 table.insert(words, word)
                  end
                  
****0             local lines = {}
****0             local currentLine = ""
****0             for i, word in ipairs(words) do
****0                 if #currentLine + #word + 1 <= TOOLTIP_LINE_LENGTH then
****0                     currentLine = currentLine .. (currentLine == "" and "" or " ") .. word
                      else
****0                     table.insert(lines, currentLine)
****0                     currentLine = word
                      end
                  end
****0             if currentLine ~= "" then
****0                 table.insert(lines, currentLine)
                  end
                  
****0             for _, line in ipairs(lines) do
****0                 GameTooltip:AddLine(line, 0.7, 0.7, 0.7)
                  end
              end
****0         GameTooltip:Show()
          end)
****0     frame:SetScript("OnLeave", function(self)
****0         GameTooltip:Hide()
          end)
      end

   13 function UI:MakeFrameDraggable()
****0     mainFrame:SetMovable(true)
****0     mainFrame:EnableMouse(true)
****0     mainFrame:RegisterForDrag("LeftButton")
          
****0     mainFrame:SetScript("OnDragStart", function(self)
****0         if HealIQ.db and HealIQ.db.ui and not HealIQ.db.ui.locked then
****0             self:StartMoving()
****0             isDragging = true
              end
          end)
          
****0     mainFrame:SetScript("OnDragStop", function(self)
****0         if isDragging then
****0             self:StopMovingOrSizing()
****0             isDragging = false
                  
                  -- Save position if database is available
****0             if HealIQ.db and HealIQ.db.ui then
****0                 local point, relativeTo, relativePoint, xOfs, yOfs = self:GetPoint()
****0                 HealIQ.db.ui.x = xOfs
****0                 HealIQ.db.ui.y = yOfs
****0                 HealIQ:Print("UI position saved")
                  end
              end
          end)
          
          -- Right-click to toggle lock
****0     mainFrame:SetScript("OnMouseUp", function(self, button)
****0         if button == "RightButton" then
****0             UI:ToggleLock()
              end
          end)
      end

   13 function UI:SetupEventHandlers()
          -- Scale with UI changes
****0     local scaleFrame = CreateFrame("Frame")
****0     scaleFrame:RegisterEvent("UI_SCALE_CHANGED")
****0     scaleFrame:SetScript("OnEvent", function()
****0         UI:UpdateScale()
          end)
      end

   13 function UI:UpdateSuggestion(suggestion)
****0     HealIQ:SafeCall(function()
****0         if not mainFrame then
****0             return
              end
              
****0         if not suggestion then
****0             mainFrame:Hide()
****0             return
              end
              
              -- Show the frame
****0         mainFrame:Show()
              
              -- Update primary icon
****0         if iconFrame and iconFrame.icon then
****0             iconFrame.icon:SetTexture(suggestion.icon)
****0             iconFrame.icon:SetDesaturated(false)
                  
                  -- Store current suggestion for click handling
****0             iconFrame.currentSuggestion = suggestion
                  
                  -- Show glow effect for primary suggestion
****0             if iconFrame.glow then
****0                 iconFrame.glow:Show()
****0                 if iconFrame.glowAnimation then
****0                     iconFrame.glowAnimation:Play()
                      end
                  end
                  
                  -- Update targeting indicator
****0             if iconFrame.targetingIcon and HealIQ.Engine then
                      -- Check if targeting icons are enabled (default to true if not set)
****0                 local showTargetingIcon = HealIQ.db.ui.showTargetingIcon
****0                 if showTargetingIcon == nil then
****0                     showTargetingIcon = true -- Default to true
                      end
                      
****0                 if showTargetingIcon then
****0                     local targetIcon = HealIQ.Engine:GetTargetingSuggestionsIcon(suggestion)
****0                     if targetIcon then
****0                         iconFrame.targetingIcon.icon:SetTexture(targetIcon)
****0                         iconFrame.targetingIcon:Show()
                          else
****0                         iconFrame.targetingIcon:Hide()
                          end
                      else
****0                     iconFrame.targetingIcon:Hide()
                      end
****0             elseif iconFrame.targetingIcon then
****0                 iconFrame.targetingIcon:Hide()
                  end
              end
              
              -- Update spell name with targeting info
****0         if spellNameText and HealIQ.db and HealIQ.db.ui and HealIQ.db.ui.showSpellName then
****0             local displayText = suggestion.name
                  
                  -- Add targeting suggestion to spell name if enabled
****0             local showTargeting = HealIQ.db.ui.showTargeting
****0             if showTargeting == nil then
****0                 showTargeting = true -- Default to true if not set
                  end
                  
****0             if showTargeting and HealIQ.Engine then
****0                 local targetText = HealIQ.Engine:GetTargetingSuggestionsText(suggestion)
****0                 if targetText then
                          -- Truncate target text if it's too long to prevent overflow
****0                     local maxTargetLength = 12 -- Reasonable limit for target text
****0                     if #targetText > maxTargetLength then
****0                         targetText = targetText:sub(1, maxTargetLength - 2) .. ".."
                          end
                          
                          -- Format the text with better spacing and color
****0                     displayText = displayText .. "\n|cFFFFCC00→ " .. targetText .. "|r"
                      end
                  end
                  
****0             spellNameText:SetText(displayText)
****0             spellNameText:Show()
              else
****0             if spellNameText then
****0                 spellNameText:Hide()
                  end
              end
              
              -- Update cooldown display
****0         if cooldownFrame and HealIQ.db and HealIQ.db.ui and HealIQ.db.ui.showCooldown then
****0             self:UpdateCooldownDisplay(suggestion)
              end
          end)
      end

   13 function UI:UpdateQueue(queue)
****0     if not queueIcons then
****0         return
          end
          
          -- Show/hide queue frame based on settings
****0     if queueFrame then
****0         if HealIQ.db and HealIQ.db.ui and HealIQ.db.ui.showQueue then
****0             queueFrame:Show()
              else
****0             queueFrame:Hide()
****0             return
              end
          end
          
          -- Hide all queue icons first
****0     for _, queueIcon in ipairs(queueIcons) do
****0         queueIcon:Hide()
          end
          
          -- Update queue icons with new suggestions
****0     for i, suggestion in ipairs(queue) do
****0         if i > 1 and i <= #queueIcons + 1 then -- Skip first suggestion (it's the primary)
****0             local queueIcon = queueIcons[i - 1]
****0             if queueIcon then
****0                 queueIcon.icon:SetTexture(suggestion.icon)
****0                 queueIcon:Show()
                      
                      -- Update position text to show queue order more clearly
****0                 if queueIcon.positionText then
****0                     queueIcon.positionText:SetText(tostring(i)) -- Show actual queue position
                      end
                      
                      -- Add enhanced tooltip for queue items with better information
****0                 queueIcon:SetScript("OnEnter", function(self)
****0                     GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
****0                     GameTooltip:AddLine(suggestion.name, 1, 1, 1)
****0                     GameTooltip:AddLine("Queue Position: " .. i, 0.7, 0.7, 0.7)
****0                     GameTooltip:AddLine("Priority: " .. (suggestion.priority or "Normal"), 0.5, 0.8, 1)
****0                     GameTooltip:AddLine(" ")
                          
                          -- Add contextual information about why this spell is suggested
****0                     local context = UI:GetSpellContext(suggestion)
****0                     if context then
****0                         GameTooltip:AddLine(context, 0.6, 0.6, 0.6)
                          end
                          
****0                     GameTooltip:AddLine("This suggestion will appear when higher", 0.6, 0.6, 0.6)
****0                     GameTooltip:AddLine("priority spells become unavailable.", 0.6, 0.6, 0.6)
****0                     GameTooltip:Show()
                      end)
                      
****0                 queueIcon:SetScript("OnLeave", function(self)
****0                     GameTooltip:Hide()
                      end)
                      
                      -- Store suggestion data for tooltip context
****0                 queueIcon.suggestion = suggestion
                  end
              end
          end
      end

      -- Helper function to provide contextual information about spells
   13 function UI:GetSpellContext(suggestion)
****0     if not suggestion then return nil end
          
****0     local contexts = {
              ["Rejuvenation"] = "Basic HoT coverage for targets without heals",
              ["Lifebloom"] = "Essential HoT for tank targets",
              ["Wild Growth"] = "AoE healing when multiple allies take damage",
              ["Regrowth"] = "Strong direct heal, especially with Clearcasting",
              ["Swiftmend"] = "Instant heal when HoTs are active on target",
              ["Efflorescence"] = "Ground-based AoE healing effect",
              ["Ironbark"] = "Damage reduction for targets under heavy fire",
              ["Tranquility"] = "Emergency raid-wide healing cooldown",
              ["Incarnation"] = "Enhanced healing form for intensive phases",
              ["Nature's Swiftness"] = "Makes next spell instant cast",
              ["Barkskin"] = "Personal damage reduction",
****0         ["Flourish"] = "Extends duration of active HoTs"
          }
          
****0     return contexts[suggestion.name]
      end

   13 function UI:UpdateCooldownDisplay(suggestion)
****0     if not cooldownFrame then
****0         return
          end
          
          -- Get cooldown info from tracker
****0     local tracker = HealIQ.Tracker
****0     if not tracker then
****0         return
          end
          
****0     local spellName = suggestion.name:lower():gsub(" ", "")
****0     local cooldownInfo = tracker:GetCooldownInfo(spellName)
          
****0     if cooldownInfo and cooldownInfo.remaining > 0 then
****0         cooldownFrame:SetCooldown(cooldownInfo.start, cooldownInfo.duration)
****0         cooldownFrame:Show()
          else
****0         cooldownFrame:Hide()
          end
      end



   13 function UI:UpdateScale()
   27     if mainFrame and HealIQ.db and HealIQ.db.ui then
****0         mainFrame:SetScale(HealIQ.db.ui.scale)
          end
      end

   13 function UI:UpdatePosition()
    9     if mainFrame and HealIQ.db and HealIQ.db.ui then
****0         mainFrame:ClearAllPoints()
****0         mainFrame:SetPoint("CENTER", UIParent, "CENTER", HealIQ.db.ui.x, HealIQ.db.ui.y)
          end
      end

   13 function UI:ToggleLock()
****0     if not HealIQ.db or not HealIQ.db.ui then
****0         HealIQ:Print("UI database not yet initialized")
****0         return
          end
          
****0     HealIQ.db.ui.locked = not HealIQ.db.ui.locked
          
****0     if HealIQ.db.ui.locked then
****0         HealIQ:Print("UI locked")
          else
****0         HealIQ:Print("UI unlocked (drag to move, right-click to lock)")
          end
          
          -- Update border based on new state
****0     self:UpdatePositionBorder()
      end

   13 function UI:Show()
   14     if mainFrame then
   14         mainFrame:Show()
          end
      end

   13 function UI:Hide()
   19     if mainFrame then
   19         mainFrame:Hide()
          end
      end

   13 function UI:Toggle()
****0     if mainFrame then
****0         if mainFrame:IsShown() then
****0             self:Hide()
              else
****0             self:Show()
              end
          end
      end

   13 function UI:SetEnabled(enabled)
   33     if enabled then
   14         self:Show()
          else
   19         self:Hide()
          end
      end

      -- Configuration methods
   13 function UI:SetScale(scale)
   27     if scale and scale > 0.5 and scale <= 2.0 and HealIQ.db and HealIQ.db.ui then
   27         HealIQ.db.ui.scale = scale
   27         self:UpdateScale()
   27         HealIQ:Print("UI scale set to " .. scale)
          end
      end

   13 function UI:SetShowSpellName(show)
   18     if HealIQ.db and HealIQ.db.ui then
   18         HealIQ.db.ui.showSpellName = show
   18         if spellNameText then
****0             if show then
****0                 spellNameText:Show()
                  else
****0                 spellNameText:Hide()
                  end
              end
          end
      end

   13 function UI:SetShowCooldown(show)
   18     if HealIQ.db and HealIQ.db.ui then
   18         HealIQ.db.ui.showCooldown = show
   18         if cooldownFrame then
****0             if show then
****0                 cooldownFrame:Show()
                  else
****0                 cooldownFrame:Hide()
                  end
              end
          end
      end

   13 function UI:ResetPosition()
    9     if HealIQ.db and HealIQ.db.ui then
    9         HealIQ.db.ui.x = 0
    9         HealIQ.db.ui.y = 0
    9         self:UpdatePosition()
    9         HealIQ:Print("UI position reset to center")
          end
      end

   13 function UI:ResetMinimapPosition()
****0     if HealIQ.db and HealIQ.db.ui then
****0         HealIQ.db.ui.minimapAngle = -math.pi/4 -- Reset to default angle (top-right)
****0         if minimapButton then
****0             local radius = self:CalculateMinimapButtonRadius()
                  
                  -- Fixed: Position relative to Minimap center, not UIParent
****0             local x = radius * math.cos(HealIQ.db.ui.minimapAngle)
****0             local y = radius * math.sin(HealIQ.db.ui.minimapAngle)
****0             minimapButton:ClearAllPoints()
****0             minimapButton:SetPoint("CENTER", Minimap, "CENTER", x, y)
              end
****0         HealIQ:Print("Minimap icon position reset")
          end
      end

      -- Debug/testing functions
   13 function UI:TestDisplay()
****0     local testSuggestion = {
              id = 774,
              name = "Rejuvenation",
              icon = "Interface\\Icons\\Spell_Nature_Rejuvenation",
              priority = 5,
          }
          
****0     self:UpdateSuggestion(testSuggestion)
****0     HealIQ:Print("Test display activated")
      end

   13 function UI:TestQueue()
****0     local testQueue = {
              {
                  id = 774,
                  name = "Rejuvenation",
                  icon = "Interface\\Icons\\Spell_Nature_Rejuvenation",
                  priority = 5,
              },
              {
                  id = 48438,
                  name = "Wild Growth",
                  icon = "Interface\\Icons\\Ability_Druid_WildGrowth",
                  priority = 4,
              },
              {
                  id = 18562,
                  name = "Swiftmend",
                  icon = "Interface\\Icons\\INV_Relics_IdolofRejuvenation",
                  priority = 6,
              },
              {
                  id = 8936,
                  name = "Regrowth",
                  icon = "Interface\\Icons\\Spell_Nature_ResistNature",
                  priority = 7,
              }
          }
          
****0     self:UpdateSuggestion(testQueue[1])
****0     self:UpdateQueue(testQueue)
****0     HealIQ:Print("Test queue display activated with " .. #testQueue .. " queue items")
      end

   13 function UI:GetFrameInfo()
   21     if mainFrame then
****0         local point, relativeTo, relativePoint, xOfs, yOfs = mainFrame:GetPoint()
****0         return {
                  point = point,
                  relativeTo = relativeTo and relativeTo:GetName() or "nil",
                  relativePoint = relativePoint,
                  x = xOfs,
                  y = yOfs,
                  scale = mainFrame:GetScale(),
                  shown = mainFrame:IsShown(),
****0             locked = HealIQ.db and HealIQ.db.ui and HealIQ.db.ui.locked or false
              }
          end
   21     return nil
      end

   13 function UI:ToggleOptionsFrame()
    3     if optionsFrame then
****0         if optionsFrame:IsShown() then
****0             optionsFrame:Hide()
              else
****0             self:UpdateOptionsFrame()
****0             optionsFrame:Show()
              end
          end
      end

   13 function UI:RecreateFrames()
          -- Store current visibility state before destroying frames
   18     local wasVisible = mainFrame and mainFrame:IsShown()
          
          -- Hide and remove existing frames
   18     if mainFrame then
    9         mainFrame:Hide()
    9         mainFrame = nil
          end
          
          -- Clear references
   18     iconFrame = nil
   18     spellNameText = nil
   18     cooldownFrame = nil
   18     queueFrame = nil
   18     queueIcons = {}
          
          -- Recreate the main frame with new settings
   18     self:CreateMainFrame()
          
          -- Update position and scale
****0     self:UpdatePosition()
****0     self:UpdateScale()
          
          -- Restore visibility state if addon is enabled
****0     if wasVisible and HealIQ.db and HealIQ.db.enabled then
****0         self:Show()
          end
          
****0     HealIQ:Print("UI frames recreated with new settings")
      end

   13 function UI:UpdatePositionBorder()
          -- Check for UI frame existence first (original function logic)
****0     if not mainFrame or not mainFrame.border then
****0         return
          end
          
          -- If database isn't ready, hide border and return (graceful degradation)
****0     if not HealIQ.db or not HealIQ.db.ui then
****0         mainFrame.border:Hide()
****0         return
          end
          
          -- Only show border when explicitly requested via showPositionBorder setting
****0     if HealIQ.db.ui.showPositionBorder then
              -- Show positioning aid border (cyan)
****0         mainFrame.border:SetColorTexture(unpack(BORDER_COLORS.positioning))
****0         mainFrame.border:Show()
          else
              -- Hide border when not explicitly requested
****0         mainFrame.border:Hide()
          end
      end

   13 function UI:UpdateOptionsFrame()
    9     if not optionsFrame then
    9         return
          end
          
          -- Only update if database is available
****0     if not HealIQ.db then
****0         return
          end
          
          -- Update enable checkbox
****0     if optionsFrame.enableCheck then
****0         optionsFrame.enableCheck:SetChecked(HealIQ.db.enabled)
          end
          
          -- Update debug checkbox
****0     if optionsFrame.debugCheck then
****0         optionsFrame.debugCheck:SetChecked(HealIQ.db.debug)
          end
          
          -- Update session stats checkbox
****0     if optionsFrame.statsCheck then
****0         optionsFrame.statsCheck:SetChecked(HealIQ.sessionStats and HealIQ.sessionStats.startTime ~= nil)
          end
          
          -- Update UI options
****0     if HealIQ.db.ui then
              -- Update scale slider
****0         if optionsFrame.scaleSlider then
****0             optionsFrame.scaleSlider:SetValue(HealIQ.db.ui.scale)
              end
              
              -- Update queue scale slider
****0         if optionsFrame.queueScaleSlider then
****0             optionsFrame.queueScaleSlider:SetValue(HealIQ.db.ui.queueScale or 0.75)
              end
              
              -- Update lock button text
****0         if optionsFrame.lockButton then
****0             optionsFrame.lockButton:SetText(HealIQ.db.ui.locked and "Unlock UI" or "Lock UI")
              end
              
              -- Update display option checkboxes
****0         if optionsFrame.showNameCheck then
****0             optionsFrame.showNameCheck:SetChecked(HealIQ.db.ui.showSpellName)
              end
              
****0         if optionsFrame.showCooldownCheck then
****0             optionsFrame.showCooldownCheck:SetChecked(HealIQ.db.ui.showCooldown)
              end
              
****0         if optionsFrame.showIconCheck then
****0             optionsFrame.showIconCheck:SetChecked(HealIQ.db.ui.showIcon)
              end
              
****0         if optionsFrame.showTargetingCheck then
****0             local showTargeting = HealIQ.db.ui.showTargeting
****0             if showTargeting == nil then
****0                 showTargeting = true -- Default to true
                  end
****0             optionsFrame.showTargetingCheck:SetChecked(showTargeting)
              end
              
****0         if optionsFrame.showTargetingIconCheck then
****0             local showTargetingIcon = HealIQ.db.ui.showTargetingIcon
****0             if showTargetingIcon == nil then
****0                 showTargetingIcon = true -- Default to true
                  end
****0             optionsFrame.showTargetingIconCheck:SetChecked(showTargetingIcon)
              end
              
              -- Update frame positioning checkbox
****0         if optionsFrame.showFrameCheck then
****0             optionsFrame.showFrameCheck:SetChecked(HealIQ.db.ui.showPositionBorder)
              end
              
              -- Update queue options
****0         if optionsFrame.showQueueCheck then
****0             optionsFrame.showQueueCheck:SetChecked(HealIQ.db.ui.showQueue)
              end
              
****0         if optionsFrame.queueSizeSlider then
****0             optionsFrame.queueSizeSlider:SetValue(HealIQ.db.ui.queueSize or 3)
              end
              
****0         if optionsFrame.queueLayoutButton then
****0             local layout = HealIQ.db.ui.queueLayout or "horizontal"
****0             optionsFrame.queueLayoutButton:SetText(layout:sub(1,1):upper() .. layout:sub(2))
              end
          end
          
          -- Update rule checkboxes
****0     if optionsFrame.ruleChecks and HealIQ.db.rules then
****0         for rule, checkbox in pairs(optionsFrame.ruleChecks) do
****0             checkbox:SetChecked(HealIQ.db.rules[rule])
              end
          end
          
          -- Update strategy controls
****0     if optionsFrame.strategyControls and HealIQ.db.strategy then
****0         for setting, control in pairs(optionsFrame.strategyControls) do
****0             local value = HealIQ.db.strategy[setting]
****0             if type(control) == "table" and control.slider then
                      -- Numeric setting with slider
****0                 control.slider:SetValue(value or 0)
****0                 if control.valueText then
****0                     control.valueText:SetText(string.format("%.1f", value or 0))
                      end
                  else
                      -- Boolean setting with checkbox
****0                 control:SetChecked(value)
                  end
              end
          end
          
          -- Update talent status
****0     if optionsFrame.talentStatusText then
****0         self:UpdateTalentStatus(optionsFrame.talentStatusText)
          end
      end

   13 HealIQ.UI = UI

==============================================================================
WoWAPIMock.lua
==============================================================================
      -- WoWAPIMock.lua
      -- Mock WoW API functions for external testing
      -- This allows testing WoW-dependent code outside the game client

    2 local WoWAPIMock = {}

      -- Mock frame system
    2 local mockFrames = {}
    2 local frameCounter = 0

      -- Mock game state
    2 local mockGameState = {
    2     time = 1000,
    2     inCombat = false,
    2     playerName = "TestPlayer",
    2     playerClass = "DRUID",
    2     targetExists = true,
    2     targetHealth = 0.8,
    2     targetMaxHealth = 10000,
    2     focusExists = true,
    2     focusHealth = 0.6,
    2     unitBuffs = {},
    2     spellCooldowns = {},
    2     combatLogEvents = {}
      }

      -- Mock Frame class
    2 local MockFrame = {}
    2 MockFrame.__index = MockFrame

    2 function MockFrame:new(frameType, name, parent)
****0     local frame = {
              frameType = frameType or "Frame",
              name = name,
              parent = parent,
              children = {},
              scripts = {},
              size = {width = 100, height = 100},
              position = {x = 0, y = 0},
              visible = true,
              enabled = true,
              texture = nil,
              text = "",
****0         fontString = nil
          }
****0     setmetatable(frame, self)
****0     frameCounter = frameCounter + 1
****0     frame.id = frameCounter
****0     mockFrames[frame.id] = frame
****0     return frame
      end

    2 function MockFrame:SetSize(width, height)
****0     self.size.width = width
****0     self.size.height = height
      end

    2 function MockFrame:SetPoint(point, relativeTo, relativePoint, x, y)
****0     self.position.x = x or 0
****0     self.position.y = y or 0
      end

    2 function MockFrame:SetScript(event, handler)
****0     self.scripts[event] = handler
      end

    2 function MockFrame:RegisterEvent(event)
          -- Mock event registration
****0     if not self.events then
****0         self.events = {}
          end
****0     self.events[event] = true
      end

    2 function MockFrame:UnregisterEvent(event)
****0     if self.events then
****0         self.events[event] = nil
          end
      end

    2 function MockFrame:UnregisterAllEvents()
****0     self.events = {}
      end

    2 function MockFrame:Show()
****0     self.visible = true
      end

    2 function MockFrame:Hide()
****0     self.visible = false
      end

    2 function MockFrame:SetTexture(texture)
****0     self.texture = texture
      end

    2 function MockFrame:SetText(text)
****0     self.text = text or ""
      end

    2 function MockFrame:CreateFontString(name, layer, template)
****0     local fontString = MockFrame:new("FontString", name, self)
****0     self.fontString = fontString
****0     return fontString
      end

    2 function MockFrame:SetWidth(width)
****0     self.size.width = width
      end

    2 function MockFrame:SetWordWrap(wrap)
****0     self.wordWrap = wrap
      end

      -- Mock WoW API Functions
    2 function WoWAPIMock.CreateFrame(frameType, name, parent, template)
****0     return MockFrame:new(frameType, name, parent)
      end

    2 function WoWAPIMock.GetTime()
****0     return mockGameState.time
      end

    2 function WoWAPIMock.InCombatLockdown()
****0     return mockGameState.inCombat
      end

    2 function WoWAPIMock.UnitExists(unit)
****0     if unit == "player" then return true end
****0     if unit == "target" then return mockGameState.targetExists end
****0     if unit == "focus" then return mockGameState.focusExists end
****0     return false
      end

    2 function WoWAPIMock.UnitHealth(unit)
****0     if unit == "target" then
****0         return math.floor(mockGameState.targetHealth * mockGameState.targetMaxHealth)
          end
****0     return 8000 -- Default health
      end

    2 function WoWAPIMock.UnitHealthMax(unit)
****0     if unit == "target" then
****0         return mockGameState.targetMaxHealth
          end
****0     return 10000 -- Default max health
      end

    2 function WoWAPIMock.UnitName(unit)
****0     if unit == "player" then return mockGameState.playerName end
****0     if unit == "target" then return "TestTarget" end
****0     if unit == "focus" then return "TestFocus" end
****0     return "UnknownUnit"
      end

    2 function WoWAPIMock.UnitClass(unit)
****0     if unit == "player" then return "Druid", mockGameState.playerClass end
****0     return "Warrior", "WARRIOR"
      end

    2 function WoWAPIMock.GetSpellCooldown(spellID)
****0     local cooldown = mockGameState.spellCooldowns[spellID] or {start = 0, duration = 0}
****0     return cooldown.start, cooldown.duration, 1
      end

    2 function WoWAPIMock.GetSpellInfo(spellID)
****0     local spellNames = {
              [774] = "Rejuvenation",
              [33763] = "Lifebloom",
              [8936] = "Regrowth",
              [2061] = "Flash Heal",
****0         [139] = "Renew"
          }
****0     return spellNames[spellID] or "Unknown Spell"
      end

    2 function WoWAPIMock.UnitBuff(unit, index, filter)
****0     local buffs = mockGameState.unitBuffs[unit] or {}
****0     local buff = buffs[index]
****0     if buff then
****0         return buff.name, buff.icon, buff.count, buff.debuffType,
****0                buff.duration, buff.expirationTime, buff.source,
****0                buff.isStealable, buff.nameplateShowPersonal, buff.spellId
          end
****0     return nil
      end

    2 function WoWAPIMock.CombatLogGetCurrentEventInfo()
****0     local events = mockGameState.combatLogEvents
****0     if #events > 0 then
****0         return unpack(table.remove(events, 1))
          end
****0     return nil
      end

      -- Additional WoW API functions
    2 function WoWAPIMock.GetPlayerInfoByGUID(guid)
****0     return nil, "DRUID", "Tauren", "Male", 1, "TestPlayer"
      end

    2 function WoWAPIMock.IsInInstance()
****0     return false, "none"
      end

    2 function WoWAPIMock.GetRealmName()
****0     return "TestRealm"
      end

    2 function WoWAPIMock.UnitLevel(unit)
****0     return 80
      end

      -- Debug/utility function to access created frames (used for testing frame management)
    1 function WoWAPIMock.GetMockFrameCount()
    1     local count = 0
****0     for _ in pairs(mockFrames) do
    1         count = count + 1
          end
    1     return count
      end

    1 function WoWAPIMock.UnitPowerType(unit)
    1     return 0 -- Mana
      end

    1 function WoWAPIMock.UnitPower(unit, powerType)
****0     return 8000
      end

    2 function WoWAPIMock.UnitPowerMax(unit, powerType)
****0     return 10000
      end

    1 function WoWAPIMock.GetAddOnMetadata(addon, field)
****0     if addon == "HealIQ" and field == "Version" then
****0         return "0.0.25"
          end
****0     return nil
      end

      -- Mock utility functions
    1 function WoWAPIMock.SetGameState(state)
    1     for key, value in pairs(state) do
****0         mockGameState[key] = value
          end
      end

    1 function WoWAPIMock.AddCombatLogEvent(...)
****0     table.insert(mockGameState.combatLogEvents, {...})
      end

    2 function WoWAPIMock.SetSpellCooldown(spellID, start, duration)
****0     mockGameState.spellCooldowns[spellID] = {start = start, duration = duration}
      end

    1 function WoWAPIMock.SetUnitBuff(unit, index, buffData)
****0     if not mockGameState.unitBuffs[unit] then
****0         mockGameState.unitBuffs[unit] = {}
          end
****0     mockGameState.unitBuffs[unit][index] = buffData
      end

    1 function WoWAPIMock.Reset()
****0     mockFrames = {}
****0     frameCounter = 0
****0     mockGameState = {
              time = 1000,
              inCombat = false,
              playerName = "TestPlayer",
              playerClass = "DRUID",
    1         targetExists = true,
              targetHealth = 0.8,
              targetMaxHealth = 10000,
    1         focusExists = true,
              focusHealth = 0.6,
              unitBuffs = {},
              spellCooldowns = {},
****0         combatLogEvents = {}
          }
      end

      -- Install mock functions into global namespace for testing
    1 function WoWAPIMock.Install()
          -- Frame creation
****0     _G.CreateFrame = WoWAPIMock.CreateFrame
          
          -- Time and combat
****0     _G.GetTime = WoWAPIMock.GetTime
****0     _G.InCombatLockdown = WoWAPIMock.InCombatLockdown
          
          -- Unit functions
****0     _G.UnitExists = WoWAPIMock.UnitExists
****0     _G.UnitHealth = WoWAPIMock.UnitHealth
****0     _G.UnitHealthMax = WoWAPIMock.UnitHealthMax
****0     _G.UnitName = WoWAPIMock.UnitName
****0     _G.UnitClass = WoWAPIMock.UnitClass
****0     _G.UnitBuff = WoWAPIMock.UnitBuff
          
          -- Spell functions
****0     _G.GetSpellCooldown = WoWAPIMock.GetSpellCooldown
****0     _G.GetSpellInfo = WoWAPIMock.GetSpellInfo
          
          -- Combat log
****0     _G.CombatLogGetCurrentEventInfo = WoWAPIMock.CombatLogGetCurrentEventInfo
          
          -- Additional API functions
****0     _G.GetPlayerInfoByGUID = WoWAPIMock.GetPlayerInfoByGUID
****0     _G.IsInInstance = WoWAPIMock.IsInInstance
    1     _G.GetRealmName = WoWAPIMock.GetRealmName
****0     _G.UnitLevel = WoWAPIMock.UnitLevel
    1     _G.UnitPowerType = WoWAPIMock.UnitPowerType
****0     _G.UnitPower = WoWAPIMock.UnitPower
****0     _G.UnitPowerMax = WoWAPIMock.UnitPowerMax
****0     _G.GetAddOnMetadata = WoWAPIMock.GetAddOnMetadata
          
          -- Mock additional globals that might be needed
****0     _G.print = _G.print or function(...) print(...) end
      end

    1 return WoWAPIMock

==============================================================================
test_runner.lua
==============================================================================
      #!/usr/bin/env lua
      -- HealIQ Test Runner for CI
      -- This script can run HealIQ tests in a CI environment without WoW

      -- Mock WoW API and globals for testing
      local function setupMockEnvironment()
          -- Mock global functions that HealIQ might use
   13     _G.print = print
   13     _G.error = error
   13     _G.type = type
   13     _G.pairs = pairs
   13     _G.ipairs = ipairs
   13     _G.table = table
   13     _G.string = string
   13     _G.math = math
   13     _G.tostring = tostring
   13     _G.tonumber = tonumber
   13     _G.pcall = pcall
   13     _G.unpack = unpack or table.unpack
   13     _G.next = next
   13     _G.getmetatable = getmetatable
   13     _G.setmetatable = setmetatable
   13     _G.rawget = rawget
   13     _G.rawset = rawset
   13     _G.select = select

          -- Mock time/date functions
   13     _G.time = os.time
   13     _G.date = os.date
   13     _G.GetTime = function() return os.time() end

          -- Mock basic WoW API functions
   13     _G.GetAddOnMetadata = function(addon, field)
****0         if addon == "HealIQ" and field == "Version" then
****0             return "0.0.25"
              end
****0         return nil
          end

          -- Mock frame creation
   13     _G.CreateFrame = function(frameType, name, parent, template)
   57         local frame = {
   57             frameType = frameType,
   57             name = name,
   57             parent = parent,
   57             template = template,
   57             children = {},

                  -- Common frame methods
                  SetSize = function(self, width, height)
   18                 self.width = width
   18                 self.height = height
                  end,
   57             GetSize = function(self) return self.width or 0, self.height or 0 end,
   57             SetWidth = function(self, width) self.width = width end,
   57             SetHeight = function(self, height) self.height = height end,
   75             SetPoint = function(self, ...) end,
   57             GetPoint = function(self) return "CENTER", nil, "CENTER", 0, 0 end,
   57             SetParent = function(self, parent) self.parent = parent end,
   57             GetParent = function(self) return self.parent end,
   71             Show = function(self) self.visible = true end,
   85             Hide = function(self) self.visible = false end,
   66             IsShown = function(self) return self.visible or false end,
   57             SetAlpha = function(self, alpha) self.alpha = alpha end,
   57             GetAlpha = function(self) return self.alpha or 1.0 end,
   57             SetScale = function(self, scale) self.scale = scale end,
   57             GetScale = function(self) return self.scale or 1.0 end,
   57             SetText = function(self, text) self.text = text end,
   57             GetText = function(self) return self.text or "" end,
   57             SetTexture = function(self, texture) self.texture = texture end,
   57             SetWordWrap = function(self, wrap) self.wordWrap = wrap end,
                  SetScript = function(self, event, handler)
   13                 self.scripts = self.scripts or {}
   13                 self.scripts[event] = handler
                  end,
                  GetScript = function(self, event)
****0                 return self.scripts and self.scripts[event]
                  end,
                  RegisterEvent = function(self, event)
   39                 self.events = self.events or {}
   39                 self.events[event] = true
                  end,
                  UnregisterEvent = function(self, event)
****0                 if self.events then
****0                     self.events[event] = nil
                      end
                  end,
                  CreateTexture = function(self, name, layer)
****0                 local texture = CreateFrame("Texture", name, self)
****0                 texture.layer = layer
****0                 return texture
                  end,
                  CreateFontString = function(self, name, layer, template)
****0                 local fontString = CreateFrame("FontString", name, self)
****0                 fontString.layer = layer
****0                 fontString.template = template
****0                 return fontString
                  end,
   57             SetVertexColor = function(self, r, g, b, a) end,
   57             GetVertexColor = function(self) return 1, 1, 1, 1 end,
   57             SetTexCoord = function(self, ...) end,
   57             SetFont = function(self, font, size, flags) end,
   57             GetFont = function(self) return "Fonts\\FRIZQT__.TTF", 12, "" end,
   57             SetTextColor = function(self, r, g, b, a) end,
   57             GetTextColor = function(self) return 1, 1, 1, 1 end,
   57             EnableMouse = function(self, enable) self.mouseEnabled = enable end,
   57             IsMouseEnabled = function(self) return self.mouseEnabled or false end,
   57             EnableMouseWheel = function(self, enable) self.mouseWheelEnabled = enable end,
   57             SetResizable = function(self, resizable) self.resizable = resizable end,
   57             IsResizable = function(self) return self.resizable or false end,
   57             SetMovable = function(self, movable) self.movable = movable end,
   57             IsMovable = function(self) return self.movable or false end,
   57             StartMoving = function(self) end,
   57             StopMovingOrSizing = function(self) end,
   57             SetMinResize = function(self, w, h) end,
   57             SetMaxResize = function(self, w, h) end
              }

              -- Add frame to global registry if named
   57         if name then
   44             _G[name] = frame
              end

   57         return frame
          end

          -- Mock other UI functions
   13     _G.UIParent = CreateFrame("Frame", "UIParent")
   13     _G.GameFontNormal = "GameFontNormal"
   13     _G.GameFontHighlight = "GameFontHighlight"
   13     _G.GameFontDisable = "GameFontDisable"
   13     _G.GameFontNormalLarge = "GameFontNormalLarge"
   13     _G.Minimap = CreateFrame("Frame", "Minimap")
   13     _G.Minimap.GetZoom = function() return 0 end
   13     _G.Minimap.SetZoom = function(zoom) end

          -- Mock game state functions
   13     _G.UnitExists = function(unit) return unit == "player" end
   13     _G.UnitName = function(unit) return unit == "player" and "TestPlayer" or nil end
   13     _G.UnitClass = function(unit)
   11         if unit == "player" then
   11             return "Druid", "DRUID"
              end
****0         return nil, nil
          end
   13     _G.GetSpellInfo = function(spellId)
****0         local spells = {
                  [774] = "Rejuvenation",
                  [8936] = "Regrowth",
****0             [5185] = "Healing Touch"
              }
****0         local name = spells[spellId] or "Unknown Spell"
****0         return name, nil, nil, nil, nil, nil, spellId
          end
   13     _G.IsSpellKnown = function(spellId) return true end
   13     _G.GetSpellCooldown = function(spellId) return 0, 0, 0, 0 end

          -- Mock saved variables
   13     _G.HealIQDB = {}

          -- Mock slash commands
   13     _G.SLASH_HEALIQ1 = "/healiq"
   13     _G.SLASH_HEALIQ2 = "/hiq"
   13     _G.SlashCmdList = {}

          -- Mock events
   13     _G.C_Timer = {
              After = function(delay, callback)
                  -- Execute immediately in tests
****0             callback()
              end
   13     }

          -- Mock LibStub (if used)
   13     _G.LibStub = function(name, silent)
****0         return nil
          end

          -- Mock debugstack for error handling
   13     _G.debugstack = function(level)
****0         return "mock debug stack"
          end

          -- Mock error handler
   13     _G.geterrorhandler = function()
              return function(msg)
****0             print("Error: " .. tostring(msg))
              end
          end

          -- Mock chat functions
   13     _G.DEFAULT_CHAT_FRAME = {
   13         AddMessage = function(self, msg) print(msg) end
   13     }

          -- Mock color functions
   13     _G.NORMAL_FONT_COLOR = {r = 1, g = 1, b = 1}
   13     _G.HIGHLIGHT_FONT_COLOR = {r = 1, g = 1, b = 0}
   13     _G.RED_FONT_COLOR = {r = 1, g = 0, b = 0}
   13     _G.GREEN_FONT_COLOR = {r = 0, g = 1, b = 0}

          -- Mock constants
   13     _G.TEXTURE = 1
   13     _G.OVERLAY = 2
   13     _G.BACKGROUND = 3
   13     _G.BORDER = 4
   13     _G.ARTWORK = 5

          -- Mock string coloring
   13     _G.YELLOW_FONT_COLOR_CODE = "|cFFFFD100"
   13     _G.FONT_COLOR_CODE_CLOSE = "|r"
      end

      -- Load and initialize the addon in a controlled environment
      local function loadAddon()
   13     setupMockEnvironment()

          -- Create addon namespace
   13     local addonName = "HealIQ"
   13     local HealIQ = {}
   13     _G[addonName] = HealIQ

          -- Set version
   13     HealIQ.version = "0.0.25"

          -- Mock essential functions
          HealIQ.SafeCall = function(self, func)
****0         local success, result = pcall(func)
****0         if not success then
****0             print("Error in SafeCall: " .. tostring(result))
              end
****0         return success, result
          end

          HealIQ.Print = function(self, message)
****0         print("HealIQ: " .. tostring(message))
          end

          HealIQ.DebugLog = function(self, message, level)
              -- Silent in tests unless debug enabled
          end

          HealIQ.Message = function(self, message)
****0         print("HealIQ: " .. tostring(message))
          end

          -- Mock database
   13     HealIQ.db = {
   13         debug = false,
   13         ui = {
   13             scale = 1.0,
   13             opacity = 1.0
   13         },
   13         general = {
   13             debug = false
   13         }
   13     }

          -- Try to load actual addon files for coverage tracking
   13     local addonFiles = {"Core.lua", "Engine.lua", "UI.lua", "Tracker.lua", "Config.lua", "Logging.lua"}

   91     for _, filename in ipairs(addonFiles) do
   78         local file = io.open(filename, "r")
   78         if file then
   78             file:close()
   78             print("Loading " .. filename .. " for coverage analysis...")

                  -- Load and execute the file
   78             local chunk, err = loadfile(filename)
   78             if chunk then
   78                 local success, result = pcall(chunk, addonName, HealIQ)
   78                 if not success then
****0                     print("Warning: Error loading " .. filename .. ": " .. tostring(result))
                      end
                  else
****0                 print("Warning: Could not load " .. filename .. ": " .. tostring(err))
                  end
              else
****0             print("Note: " .. filename .. " not found, using mock implementation")
              end
          end

          -- Ensure debug is disabled for clean test output
   13     HealIQ.debug = false
   13     if HealIQ.db then
   13         HealIQ.db.debug = false
   13         if HealIQ.db.general then
   13             HealIQ.db.general.debug = false
              end
          end

          -- Ensure we have the essential modules even if loading failed
   13     if not HealIQ.UI then
****0         HealIQ.UI = {
                  GetFrameInfo = function()
****0                 return {
                          scale = 1.0,
****0                     opacity = 1.0
                      }
                  end
              }
          end

   13     if not HealIQ.Config then
****0         HealIQ.Config = {
                  GetOption = function(self, category, option)
****0                 if category == "general" and option == "debug" then
****0                     return HealIQ.db.general.debug
                      end
****0                 return nil
                  end,
                  SetOption = function(self, category, option, value)
****0                 if category == "general" and option == "debug" then
****0                     HealIQ.db.general.debug = value
                      end
                  end
              }
          end

   13     if not HealIQ.Tracker then
****0         HealIQ.Tracker = {
                  Initialize = function() end,
                  IsSpellKnown = function(self, spellName)
                      -- Mock some known spells for druids
****0                 local knownSpells = {
                          ["Rejuvenation"] = true,
                          ["Regrowth"] = true,
****0                     ["Healing Touch"] = true
                      }
****0                 return knownSpells[spellName] or false
                  end
              }
          end

   13     return HealIQ
      end

      -- Run the tests
      local function runTests()
   12     print("=== HealIQ CI Test Runner ===")

          -- Initialize LuaCov for coverage tracking (optional)
   12     local luacov_available = pcall(require, "luacov")
   12     if not luacov_available then
****0         print("Note: LuaCov not available, running tests without coverage tracking")
          end

          -- Load addon
   12     local HealIQ = loadAddon()
   12     if not HealIQ then
****0         print("ERROR: Failed to load HealIQ addon")
****0         return false
          end

          -- Load the test module
   12     local testFile = "Tests.lua"
   12     local testChunk, err = loadfile(testFile)
   12     if not testChunk then
****0         print("ERROR: Failed to load " .. testFile .. ": " .. tostring(err))
****0         return false
          end

          -- Execute the test file in our environment
   12     local success, result = pcall(testChunk, "HealIQ", HealIQ)
   12     if not success then
****0         print("ERROR: Failed to execute " .. testFile .. ": " .. tostring(result))
****0         return false
          end

          -- Run the tests
   12     if HealIQ.Tests then
   12         print("Running HealIQ tests...")
   13         HealIQ.Tests:RunAll()

              -- Force LuaCov to save stats if available
    9         if luacov_available then
   10             local luacov = require("luacov")
    9             if luacov.save_stats then
    9                 luacov.save_stats()
                  end
              end

    9         return true
          else
****0         print("ERROR: Test module not loaded properly")
    1         return false
          end
      end

      -- Main execution
      local function main()
   11     local success = runTests()
    9     if success then
   10         print("Test execution completed")
    9         os.exit(0)
          else
    1         print("Test execution failed")
    1         os.exit(1)
          end
      end

      -- Run if this is the main script
   11 if arg and arg[0] and arg[0]:match("test_runner%.lua$") then
   11     main()
      end

==============================================================================
Summary
==============================================================================

File            Hits Missed Coverage
------------------------------------
Config.lua      118  274    30.10%
Core.lua        131  74     63.90%
Engine.lua      205  389    34.51%
Logging.lua     63   16     79.75%
Tests.lua       502  185    73.07%
Tracker.lua     66   251    20.82%
UI.lua          120  1052   10.24%
WoWAPIMock.lua  69   101    40.59%
test_runner.lua 174  52     76.99%
------------------------------------
Total           1448 2394   37.69%
